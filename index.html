<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Comprehensive Data Structures and Algorithms Learning Plan - From Beginner to Expert with LeetCode Problems, Solutions, and Real-World Applications">
    <meta name="keywords" content="DSA, Data Structures, Algorithms, LeetCode, Programming, Interview Preparation, Coding">
    <meta name="author" content="DSA Learning Plan">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Complete DSA Learning Plan - Beginner to Expert">
    <meta property="og:description" content="Master Data Structures and Algorithms with comprehensive tutorials, LeetCode solutions, and real-world applications">
    <meta property="og:type" content="website">
    <title>Complete DSA Learning Plan - Beginner to Expert | Data Structures & Algorithms</title>
    <style>
        /* CSS Reset and Variables */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary: #2563eb; --primary-dark: #1d4ed8; --secondary: #7c3aed;
            --success: #059669; --warning: #d97706; --danger: #dc2626; --expert: #7c3aed;
            --bg: #f8fafc; --surface: #ffffff; --surface-alt: #f1f5f9;
            --text: #1e293b; --text-muted: #64748b; --border: #e2e8f0;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
            --shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            --radius: 8px; --radius-lg: 12px;
        }
        html { scroll-behavior: smooth; }
        body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; line-height: 1.7; color: var(--text); background: var(--bg); }

        /* Layout */
        .container { max-width: 1400px; margin: 0 auto; padding: 0 1.5rem; margin-left: 270px; }

        /* Header */
        .header { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 50%, var(--secondary) 100%); color: white; padding: 2rem 0; position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"); }
        .header-content { position: relative; z-index: 1; }
        .header h1 { font-size: clamp(1.75rem, 4vw, 2.5rem); font-weight: 800; margin-bottom: 0.5rem; }
        .header p { font-size: 1.1rem; opacity: 0.95; max-width: 600px; }
        .progress-bar { background: rgba(255,255,255,0.2); height: 8px; border-radius: 4px; margin-top: 1.5rem; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #34d399, #10b981); width: 0%; transition: width 0.5s ease; border-radius: 4px; }
        .progress-text { margin-top: 0.5rem; font-size: 0.9rem; opacity: 0.9; }

        /* Navigation */
        .nav { background: var(--surface); border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 1000; box-shadow: var(--shadow-sm); }
        .nav-inner { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 0; flex-wrap: wrap; gap: 1rem; }
        .nav-links { display: flex; gap: 0.25rem; flex-wrap: wrap; }
        .nav-link { padding: 0.5rem 1rem; color: var(--text); text-decoration: none; border-radius: var(--radius); font-weight: 500; font-size: 0.9rem; transition: all 0.2s; }
        .nav-link:hover, .nav-link.active { background: var(--primary); color: white; }
        .nav-toggle { display: none; background: none; border: none; padding: 0.5rem; cursor: pointer; }
        .nav-toggle svg { width: 24px; height: 24px; }

        /* Main Content */
        main { padding: 2rem 0 4rem; }

        /* Sections */
        .section { background: var(--surface); border-radius: var(--radius-lg); box-shadow: var(--shadow); margin-bottom: 2rem; overflow: hidden; }
        .section-header { padding: 1.5rem 2rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .section-header h2 { font-size: 1.5rem; color: var(--text); flex: 1; }
        .section-body { padding: 2rem; }

        /* Badges */
        .badge { display: inline-flex; align-items: center; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .badge-beginner { background: #d1fae5; color: #065f46; }
        .badge-intermediate { background: #fef3c7; color: #92400e; }
        .badge-advanced { background: #fee2e2; color: #991b1b; }
        .badge-expert { background: #ede9fe; color: #5b21b6; }
        .badge-easy { background: #d1fae5; color: #065f46; }
        .badge-medium { background: #fef3c7; color: #92400e; }
        .badge-hard { background: #fee2e2; color: #991b1b; }

        /* Topic Cards */
        .topic-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-top: 1.5rem; }
        .topic-card { background: var(--surface-alt); border-radius: var(--radius); padding: 1.5rem; border: 1px solid var(--border); transition: all 0.3s; }
        .topic-card:hover { transform: translateY(-2px); box-shadow: var(--shadow); border-color: var(--primary); }
        .topic-card h4 { color: var(--primary); margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem; }
        .topic-card p { color: var(--text-muted); font-size: 0.95rem; margin-bottom: 1rem; }

        /* Complexity Badge */
        .complexity { display: inline-flex; gap: 1rem; flex-wrap: wrap; margin: 1rem 0; }
        .complexity span { font-size: 0.85rem; padding: 0.25rem 0.5rem; background: var(--surface); border-radius: 4px; border: 1px solid var(--border); }
        .complexity .time { border-color: var(--primary); color: var(--primary); }
        .complexity .space { border-color: var(--secondary); color: var(--secondary); }

        /* Code Blocks */
        .code-tabs { display: flex; gap: 0.25rem; margin-bottom: -1px; position: relative; z-index: 1; flex-wrap: wrap; }
        .code-tab { padding: 0.5rem 1rem; background: var(--surface-alt); border: 1px solid var(--border); border-bottom: none; border-radius: var(--radius) var(--radius) 0 0; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.2s; }
        .code-tab.active { background: #1e293b; color: white; border-color: #1e293b; }
        .code-block { background: #1e293b; color: #e2e8f0; padding: 1.5rem; border-radius: 0 var(--radius) var(--radius) var(--radius); overflow-x: auto; font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.9rem; line-height: 1.6; }
        .code-block code { display: block; white-space: pre; }
        .code-content { display: none; }
        .code-content.active { display: block; }

        /* Syntax Highlighting */
        .keyword { color: #c792ea; }
        .function { color: #82aaff; }
        .string { color: #c3e88d; }
        .number { color: #f78c6c; }
        .comment { color: #676e95; font-style: italic; }
        .class-name { color: #ffcb6b; }
        .operator { color: #89ddff; }

        /* LeetCode Problems */
        .problem-list { margin-top: 1.5rem; }
        .problem-item { background: var(--surface-alt); border: 1px solid var(--border); border-radius: var(--radius); margin-bottom: 1rem; overflow: hidden; }
        .problem-header { padding: 1rem 1.5rem; display: flex; align-items: center; gap: 1rem; cursor: pointer; transition: background 0.2s; flex-wrap: wrap; }
        .problem-header:hover { background: var(--surface); }
        .problem-title { flex: 1; font-weight: 600; color: var(--text); }
        .problem-content { padding: 0 1.5rem 1.5rem; display: none; }
        .problem-item.open .problem-content { display: block; }
        .problem-item.open .problem-header { background: var(--surface); border-bottom: 1px solid var(--border); }

        /* Links */
        .link-list { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 1rem; }
        .link-btn { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text); text-decoration: none; font-size: 0.9rem; transition: all 0.2s; }
        .link-btn:hover { border-color: var(--primary); color: var(--primary); background: #eff6ff; }
        .link-btn svg { width: 16px; height: 16px; }

        /* Applications */
        .applications { background: linear-gradient(135deg, #eff6ff 0%, #f0f9ff 100%); border-radius: var(--radius); padding: 1.5rem; margin: 1.5rem 0; border-left: 4px solid var(--primary); }
        .applications h5 { color: var(--primary); margin-bottom: 0.75rem; font-size: 1rem; }
        .applications ul { margin-left: 1.25rem; color: var(--text-muted); }
        .applications li { margin-bottom: 0.5rem; }

        /* Checkbox Progress */
        .progress-check { display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; }
        .progress-check input { width: 18px; height: 18px; cursor: pointer; accent-color: var(--success); }
        .progress-check label { cursor: pointer; color: var(--text); }
        .progress-check input:checked + label { text-decoration: line-through; color: var(--text-muted); }

        /* Table of Contents */
        .toc { position: fixed; left: 0; top: 50%; transform: translateY(-50%); background: var(--surface); border-radius: 0 var(--radius) var(--radius) 0; box-shadow: var(--shadow-lg); padding: 1rem; max-height: 80vh; overflow-y: auto; z-index: 1001; width: 250px; transition: transform 0.3s; }
        .toc.hidden { transform: translateY(-50%) translateX(-100%); }
        .toc h3 { font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 1rem; }
        .toc-section { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin: 1rem 0 0.5rem 0; padding-left: 0.75rem; font-weight: 600; }
        .toc-link { display: block; padding: 0.4rem 0.75rem; color: var(--text-muted); text-decoration: none; font-size: 0.85rem; border-radius: 4px; margin-bottom: 0.25rem; transition: all 0.2s; border-left: 2px solid transparent; }
        .toc-link:hover, .toc-link.active { color: var(--primary); background: #eff6ff; border-left-color: var(--primary); }
        .toc-toggle { position: fixed; left: 1rem; top: 50%; transform: translateY(-50%); background: var(--primary); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; box-shadow: var(--shadow); z-index: 1002; display: flex; align-items: center; justify-content: center; }

        /* Footer */
        footer { background: var(--text); color: white; padding: 3rem 0; text-align: center; }
        footer p { opacity: 0.8; }

        /* Responsive */
        @media (max-width: 1024px) {
            .container { margin-left: auto; padding-left: 1.5rem; }
            .toc { transform: translateY(-50%) translateX(-100%); }
            .toc.visible { transform: translateY(-50%) translateX(0); }
        }
        @media (max-width: 768px) {
            .toc, .toc-toggle { display: none; }
            .nav-links { display: none; width: 100%; flex-direction: column; }
            .nav-links.open { display: flex; }
            .nav-toggle { display: block; }
            .section-body { padding: 1.5rem; }
            .topic-grid { grid-template-columns: 1fr; }
        }

        
        /* Thought Process */
        .thought-process { background: linear-gradient(135deg, #fef3c7 0%, #fef9c3 100%); border-radius: var(--radius); padding: 1rem 1.5rem; margin: 1rem 0; border-left: 4px solid var(--warning); }
        .thought-process h4 { color: #92400e; margin-bottom: 0.75rem; font-size: 1rem; }
        .thought-process ol { margin-left: 1.25rem; color: #78350f; }
        .thought-process li { margin-bottom: 0.5rem; font-size: 0.95rem; }
        .thought-process strong { color: #92400e; }

        
        /* Search and Filter */
        .search-filter-container { background: var(--surface); border-radius: var(--radius-lg); padding: 1.5rem; margin-bottom: 2rem; box-shadow: var(--shadow); }
        .search-box { display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .search-input { flex: 1; min-width: 250px; padding: 0.75rem 1rem; border: 2px solid var(--border); border-radius: var(--radius); font-size: 1rem; transition: border-color 0.2s; }
        .search-input:focus { outline: none; border-color: var(--primary); }
        .search-input::placeholder { color: var(--text-muted); }
        .filter-section { margin-bottom: 1rem; }
        .filter-label { font-size: 0.85rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.5rem; display: block; text-transform: uppercase; letter-spacing: 0.5px; }
        .filter-buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .filter-btn { padding: 0.4rem 1rem; border: 1px solid var(--border); border-radius: 20px; background: var(--surface); cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.2s; }
        .filter-btn:hover { border-color: var(--primary); color: var(--primary); }
        .filter-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        .filter-btn.easy { border-color: #059669; color: #059669; }
        .filter-btn.easy.active { background: #059669; color: white; }
        .filter-btn.medium { border-color: #d97706; color: #d97706; }
        .filter-btn.medium.active { background: #d97706; color: white; }
        .filter-btn.hard { border-color: #dc2626; color: #dc2626; }
        .filter-btn.hard.active { background: #dc2626; color: white; }
        .filter-stats { display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border); }
        .stat-item { font-size: 0.9rem; color: var(--text-muted); }
        .stat-item strong { color: var(--text); }
        .no-results { text-align: center; padding: 2rem; color: var(--text-muted); }
        .problem-hidden { display: none !important; }
        
        /* Pattern Tags */
        .pattern-tag { display: inline-flex; align-items: center; padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.7rem; font-weight: 500; margin-left: 0.5rem; background: #eff6ff; color: #1d4ed8; }

        /* Print Styles */
        @media print {
            .nav, .toc, .toc-toggle, .nav-toggle, footer { display: none; }
            .header { position: relative; }
            .section { break-inside: avoid; box-shadow: none; border: 1px solid var(--border); }
            .problem-content { display: block !important; }
            body { background: white; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <h1>üöÄ Complete DSA Learning Plan</h1>
                <p>Master Data Structures and Algorithms from Beginner to Expert with hands-on LeetCode problems, detailed solutions, and real-world applications.</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p class="progress-text">Progress: <span id="progressPercent">0</span>% complete (<span id="progressCount">0</span>/<span id="totalCount">0</span> topics)</p>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-inner">
                <button class="nav-toggle" onclick="toggleNav()" aria-label="Toggle navigation">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
                <div class="nav-links" id="navLinks">
                    <a href="#overview" class="nav-link">Overview</a>
                    <a href="#beginner" class="nav-link">Beginner</a>
                    <a href="#intermediate" class="nav-link">Intermediate</a>
                    <a href="#advanced" class="nav-link">Advanced</a>
                    <a href="#expert" class="nav-link">Expert</a>
                    <a href="#resources" class="nav-link">Resources</a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Search and Filter Section -->
    <div class="container" style="margin-top: 2rem;">
        <div class="search-filter-container">
            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="üîç Search problems by name, number, or keyword..." onkeyup="filterProblems()">
            </div>
            <div class="filter-section">
                <span class="filter-label">Difficulty</span>
                <div class="filter-buttons" id="difficultyFilters">
                    <button class="filter-btn active" data-difficulty="all" onclick="setDifficultyFilter('all')">All</button>
                    <button class="filter-btn easy" data-difficulty="easy" onclick="setDifficultyFilter('easy')">Easy</button>
                    <button class="filter-btn medium" data-difficulty="medium" onclick="setDifficultyFilter('medium')">Medium</button>
                    <button class="filter-btn hard" data-difficulty="hard" onclick="setDifficultyFilter('hard')">Hard</button>
                </div>
            </div>
            <div class="filter-section">
                <span class="filter-label">Pattern</span>
                <div class="filter-buttons" id="patternFilters">
                    <button class="filter-btn active" data-pattern="all" onclick="setPatternFilter('all')">All</button>
                    <button class="filter-btn" data-pattern="array" onclick="setPatternFilter('array')">Array</button>
                    <button class="filter-btn" data-pattern="hash-map" onclick="setPatternFilter('hash-map')">Hash Map</button>
                    <button class="filter-btn" data-pattern="two-pointers" onclick="setPatternFilter('two-pointers')">Two Pointers</button>
                    <button class="filter-btn" data-pattern="sliding-window" onclick="setPatternFilter('sliding-window')">Sliding Window</button>
                    <button class="filter-btn" data-pattern="binary-search" onclick="setPatternFilter('binary-search')">Binary Search</button>
                    <button class="filter-btn" data-pattern="linked-list" onclick="setPatternFilter('linked-list')">Linked List</button>
                    <button class="filter-btn" data-pattern="stack" onclick="setPatternFilter('stack')">Stack</button>
                    <button class="filter-btn" data-pattern="tree" onclick="setPatternFilter('tree')">Tree</button>
                    <button class="filter-btn" data-pattern="graph" onclick="setPatternFilter('graph')">Graph</button>
                    <button class="filter-btn" data-pattern="dp" onclick="setPatternFilter('dp')">DP</button>
                    <button class="filter-btn" data-pattern="backtracking" onclick="setPatternFilter('backtracking')">Backtracking</button>
                    <button class="filter-btn" data-pattern="heap" onclick="setPatternFilter('heap')">Heap</button>
                    <button class="filter-btn" data-pattern="greedy" onclick="setPatternFilter('greedy')">Greedy</button>
                    <button class="filter-btn" data-pattern="bit" onclick="setPatternFilter('bit')">Bit Manipulation</button>
                    <button class="filter-btn" data-pattern="trie" onclick="setPatternFilter('trie')">Trie</button>
                    <button class="filter-btn" data-pattern="union-find" onclick="setPatternFilter('union-find')">Union Find</button>
                </div>
            </div>
            <div class="filter-stats">
                <span class="stat-item">Showing: <strong id="visibleCount">0</strong> problems</span>
                <span class="stat-item">Total: <strong id="totalProblems">0</strong></span>
            </div>
        </div>
    </div>

    <!-- Table of Contents Toggle -->
    <button class="toc-toggle" onclick="toggleToc()" aria-label="Toggle table of contents">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>
    </button>

    <!-- Table of Contents -->
    <aside class="toc" id="toc">
        <h3>Contents</h3>
        <a href="#overview" class="toc-link">üìã Overview</a>
        <div class="toc-section">Beginner</div>
        <a href="#complexity" class="toc-link">‚è±Ô∏è Time & Space Complexity</a>
        <a href="#arrays" class="toc-link">üìä Arrays</a>
        <a href="#strings" class="toc-link">üìù Strings</a>
        <a href="#sorting" class="toc-link">üîÑ Sorting Algorithms</a>
        <a href="#searching" class="toc-link">üîç Searching</a>
        <div class="toc-section">Intermediate</div>
        <a href="#linkedlists" class="toc-link">üîó Linked Lists</a>
        <a href="#stacks" class="toc-link">üìö Stacks</a>
        <a href="#queues" class="toc-link">üö∂ Queues</a>
        <a href="#hashtables" class="toc-link">#Ô∏è‚É£ Hash Tables</a>
        <a href="#trees" class="toc-link">üå≥ Binary Trees</a>
        <a href="#bst" class="toc-link">üå≤ BST</a>
                <a href="#sliding-window" class="toc-link">ü™ü Sliding Window</a>
        <a href="#two-pointers" class="toc-link">üëÜ Two Pointers</a>
        <a href="#trie" class="toc-link">üå≥ Tries</a>
        <a href="#union-find" class="toc-link">üîó Union Find</a>
        <a href="#greedy" class="toc-link">üí∞ Greedy</a>
        <a href="#bit-manipulation" class="toc-link">üî¢ Bit Manipulation</a>
        <div class="toc-section">Advanced</div>
        <a href="#heaps" class="toc-link">‚õ∞Ô∏è Heaps</a>
        <a href="#dp" class="toc-link">üí° Dynamic Programming</a>
        <a href="#graphs" class="toc-link">üï∏Ô∏è Graphs</a>
        <a href="#backtracking" class="toc-link">üîÑ Backtracking</a>
        <a href="#tips" class="toc-link">üíº Interview Tips</a>
    </aside>

    <!-- Main Content -->
    <main class="container">

        <!-- Overview Section -->
        <section class="section" id="overview">
            <div class="section-header">
                <h2>üìã Learning Path Overview</h2>
            </div>
            <div class="section-body">
                <p>This comprehensive DSA learning plan is designed to take you from a complete beginner to an expert level. The curriculum is structured into four progressive levels, each building upon the previous one.</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4><span class="badge badge-beginner">Beginner</span></h4>
                        <p><strong>Duration:</strong> 4-6 weeks</p>
                        <p>Arrays, Strings, Basic Sorting, Searching, Time & Space Complexity fundamentals.</p>
                        <p><strong>Prerequisites:</strong> Basic programming knowledge in any language</p>
                    </div>
                    <div class="topic-card">
                        <h4><span class="badge badge-intermediate">Intermediate</span></h4>
                        <p><strong>Duration:</strong> 6-8 weeks</p>
                        <p>Linked Lists, Stacks, Queues, Hash Tables, Binary Trees, BST, Recursion.</p>
                        <p><strong>Prerequisites:</strong> Completion of Beginner level</p>
                    </div>
                    <div class="topic-card">
                        <h4><span class="badge badge-advanced">Advanced</span></h4>
                        <p><strong>Duration:</strong> 8-10 weeks</p>
                        <p>Graphs, Dynamic Programming, Heaps, Greedy Algorithms, Backtracking.</p>
                        <p><strong>Prerequisites:</strong> Strong understanding of Intermediate concepts</p>
                    </div>
                    <div class="topic-card">
                        <h4><span class="badge badge-expert">Expert</span></h4>
                        <p><strong>Duration:</strong> 6-8 weeks</p>
                        <p>Advanced Trees, Segment Trees, Tries, Advanced Graph Algorithms, System Design.</p>
                        <p><strong>Prerequisites:</strong> Mastery of Advanced concepts</p>
                    </div>
                </div>

                <h3>üìö Recommended Study Schedule</h3>
                <ul style="margin-left: 1.5rem; margin-top: 1rem;">
                    <li><strong>Daily:</strong> 2-3 hours of focused study</li>
                    <li><strong>Practice:</strong> Solve at least 2-3 problems per topic</li>
                    <li><strong>Review:</strong> Weekly revision of completed topics</li>
                    <li><strong>Projects:</strong> Apply concepts to real-world mini-projects</li>
                </ul>
            </div>
        </section>

        <!-- BEGINNER LEVEL -->
        <section class="section" id="beginner">
            <div class="section-header">
                <h2>üå± Beginner Level</h2>
                <span class="badge badge-beginner">4-6 Weeks</span>
            </div>
            <div class="section-body">
                <p>Build a strong foundation in fundamental data structures and algorithm analysis. This level focuses on understanding basic concepts and developing problem-solving intuition.</p>
            </div>
        </section>

        <!-- Time & Space Complexity -->
        <section class="section" id="complexity">
            <div class="section-header">
                <h2>‚è±Ô∏è Time & Space Complexity</h2>
                <span class="badge badge-beginner">Beginner</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-complexity" onchange="updateProgress()">
                    <label for="check-complexity">Mark as completed</label>
                </div>

                <h3>What is Time & Space Complexity?</h3>
                <p>Time complexity measures the amount of time an algorithm takes to complete as a function of the input size. Space complexity measures the amount of memory an algorithm uses. We use Big O notation to describe the upper bound of these complexities.</p>

                <h4>Common Time Complexities (from fastest to slowest):</h4>
                <ul style="margin: 1rem 0 1rem 1.5rem;">
                    <li><strong>O(1)</strong> - Constant: Array access, hash table lookup</li>
                    <li><strong>O(log n)</strong> - Logarithmic: Binary search</li>
                    <li><strong>O(n)</strong> - Linear: Simple loop through array</li>
                    <li><strong>O(n log n)</strong> - Linearithmic: Efficient sorting (Merge Sort, Quick Sort)</li>
                    <li><strong>O(n¬≤)</strong> - Quadratic: Nested loops, Bubble Sort</li>
                    <li><strong>O(2‚Åø)</strong> - Exponential: Recursive Fibonacci without memoization</li>
                    <li><strong>O(n!)</strong> - Factorial: Generating all permutations</li>
                </ul>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Database queries:</strong> Understanding query complexity helps optimize database performance</li>
                        <li><strong>API design:</strong> Choosing appropriate algorithms for response time requirements</li>
                        <li><strong>System scaling:</strong> Predicting how systems will perform with increased load</li>
                        <li><strong>Interview preparation:</strong> Essential for analyzing and optimizing solutions</li>
                    </ul>
                </div>

                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=D6xkbGLQesk" target="_blank" class="link-btn">
                        <svg fill="currentColor" viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814z"/><path fill="#fff" d="M9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                        Big O Notation - CS Dojo
                    </a>
                    <a href="https://www.youtube.com/watch?v=BgLTDT03QtU" target="_blank" class="link-btn">
                        <svg fill="currentColor" viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814z"/><path fill="#fff" d="M9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                        Time Complexity Analysis - Abdul Bari
                    </a>
                </div>
            </div>
        </section>

        <!-- Arrays Section -->
        <section class="section" id="arrays">
            <div class="section-header">
                <h2>üìä Arrays</h2>
                <span class="badge badge-beginner">Beginner</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-arrays" onchange="updateProgress()">
                    <label for="check-arrays">Mark as completed</label>
                </div>

                <h3>What are Arrays?</h3>
                <p>An array is a contiguous block of memory that stores elements of the same type. Arrays provide O(1) random access to elements using their index, making them one of the most fundamental and efficient data structures.</p>

                <div class="complexity">
                    <span class="time">Access: O(1)</span>
                    <span class="time">Search: O(n)</span>
                    <span class="time">Insert: O(n)</span>
                    <span class="time">Delete: O(n)</span>
                    <span class="space">Space: O(n)</span>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Database tables:</strong> Rows stored as arrays for fast access</li>
                        <li><strong>Image processing:</strong> Pixels stored in 2D arrays</li>
                        <li><strong>Game development:</strong> Game boards, tile maps</li>
                        <li><strong>Scientific computing:</strong> Matrices and vectors</li>
                        <li><strong>Caching:</strong> Fixed-size cache implementations</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=QJNwK2uJyGs" target="_blank" class="link-btn">
                        <svg fill="currentColor" viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814z"/><path fill="#fff" d="M9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                        Arrays Introduction - freeCodeCamp
                    </a>
                    <a href="https://www.youtube.com/watch?v=0JUN9aDxVmI" target="_blank" class="link-btn">
                        <svg fill="currentColor" viewBox="0 0 24 24"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814z"/><path fill="#fff" d="M9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                        Array Data Structure - Neso Academy
                    </a>
                </div>

                <h3>üíª Implementation</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'arrays-python')">Python</button>
                    <button class="code-tab" onclick="switchTab(this, 'arrays-java')">Java</button>
                    <button class="code-tab" onclick="switchTab(this, 'arrays-cpp')">C++</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="arrays-python"><span class="comment"># Python Array Operations</span>

<span class="comment"># Creating arrays</span>
arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]
arr2 = [<span class="number">0</span>] * <span class="number">10</span>  <span class="comment"># Array of 10 zeros</span>

<span class="comment"># Access element - O(1)</span>
element = arr[<span class="number">2</span>]  <span class="comment"># Returns 3</span>

<span class="comment"># Modify element - O(1)</span>
arr[<span class="number">2</span>] = <span class="number">10</span>

<span class="comment"># Append to end - O(1) amortized</span>
arr.append(<span class="number">6</span>)

<span class="comment"># Insert at index - O(n)</span>
arr.insert(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># Insert 0 at beginning</span>

<span class="comment"># Delete by value - O(n)</span>
arr.remove(<span class="number">10</span>)

<span class="comment"># Delete by index - O(n)</span>
<span class="keyword">del</span> arr[<span class="number">0</span>]

<span class="comment"># Slicing - O(k) where k is slice size</span>
sub = arr[<span class="number">1</span>:<span class="number">4</span>]

<span class="comment"># Two Pointer Technique</span>
<span class="keyword">def</span> <span class="function">two_sum_sorted</span>(arr, target):
    left, right = <span class="number">0</span>, <span class="keyword">len</span>(arr) - <span class="number">1</span>
    <span class="keyword">while</span> left < right:
        current_sum = arr[left] + arr[right]
        <span class="keyword">if</span> current_sum == target:
            <span class="keyword">return</span> [left, right]
        <span class="keyword">elif</span> current_sum < target:
            left += <span class="number">1</span>
        <span class="keyword">else</span>:
            right -= <span class="number">1</span>
    <span class="keyword">return</span> []

<span class="comment"># Sliding Window Pattern</span>
<span class="keyword">def</span> <span class="function">max_sum_subarray</span>(arr, k):
    <span class="keyword">if</span> <span class="keyword">len</span>(arr) < k:
        <span class="keyword">return</span> <span class="number">0</span>
    window_sum = <span class="keyword">sum</span>(arr[:k])
    max_sum = window_sum
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(k, <span class="keyword">len</span>(arr)):
        window_sum += arr[i] - arr[i - k]
        max_sum = <span class="keyword">max</span>(max_sum, window_sum)
    <span class="keyword">return</span> max_sum</code>
                    <code class="code-content" id="arrays-java"><span class="comment">// Java Array Operations</span>

<span class="keyword">import</span> java.util.*;

<span class="keyword">public class</span> <span class="class-name">ArrayOperations</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(String[] args) {
        <span class="comment">// Creating arrays</span>
        <span class="keyword">int</span>[] arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
        <span class="keyword">int</span>[] arr2 = <span class="keyword">new int</span>[<span class="number">10</span>]; <span class="comment">// Array of 10 zeros</span>

        <span class="comment">// Using ArrayList for dynamic arrays</span>
        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();

        <span class="comment">// Access element - O(1)</span>
        <span class="keyword">int</span> element = arr[<span class="number">2</span>]; <span class="comment">// Returns 3</span>

        <span class="comment">// Modify element - O(1)</span>
        arr[<span class="number">2</span>] = <span class="number">10</span>;

        <span class="comment">// Append to ArrayList - O(1) amortized</span>
        list.add(<span class="number">6</span>);

        <span class="comment">// Insert at index - O(n)</span>
        list.add(<span class="number">0</span>, <span class="number">0</span>);

        <span class="comment">// Delete by index - O(n)</span>
        list.remove(<span class="number">0</span>);
    }

    <span class="comment">// Two Pointer Technique</span>
    <span class="keyword">public static int</span>[] <span class="function">twoSumSorted</span>(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target) {
        <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length - <span class="number">1</span>;
        <span class="keyword">while</span> (left < right) {
            <span class="keyword">int</span> sum = arr[left] + arr[right];
            <span class="keyword">if</span> (sum == target) <span class="keyword">return new int</span>[]{left, right};
            <span class="keyword">else if</span> (sum < target) left++;
            <span class="keyword">else</span> right--;
        }
        <span class="keyword">return new int</span>[]{};
    }

    <span class="comment">// Sliding Window</span>
    <span class="keyword">public static int</span> <span class="function">maxSumSubarray</span>(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {
        <span class="keyword">if</span> (arr.length < k) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">int</span> windowSum = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < k; i++) windowSum += arr[i];
        <span class="keyword">int</span> maxSum = windowSum;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i < arr.length; i++) {
            windowSum += arr[i] - arr[i - k];
            maxSum = Math.max(maxSum, windowSum);
        }
        <span class="keyword">return</span> maxSum;
    }
}</code>
                    <code class="code-content" id="arrays-cpp"><span class="comment">// C++ Array Operations</span>

<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">#include</span> &lt;vector&gt;
<span class="keyword">#include</span> &lt;algorithm&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Creating arrays</span>
    <span class="keyword">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    vector&lt;<span class="keyword">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    vector&lt;<span class="keyword">int</span>&gt; vec2(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 10 zeros</span>

    <span class="comment">// Access element - O(1)</span>
    <span class="keyword">int</span> element = vec[<span class="number">2</span>]; <span class="comment">// Returns 3</span>

    <span class="comment">// Modify element - O(1)</span>
    vec[<span class="number">2</span>] = <span class="number">10</span>;

    <span class="comment">// Append to end - O(1) amortized</span>
    vec.push_back(<span class="number">6</span>);

    <span class="comment">// Insert at position - O(n)</span>
    vec.insert(vec.begin(), <span class="number">0</span>);

    <span class="comment">// Delete by position - O(n)</span>
    vec.erase(vec.begin());

    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="comment">// Two Pointer Technique</span>
vector&lt;<span class="keyword">int</span>&gt; <span class="function">twoSumSorted</span>(vector&lt;<span class="keyword">int</span>&gt;& arr, <span class="keyword">int</span> target) {
    <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.size() - <span class="number">1</span>;
    <span class="keyword">while</span> (left < right) {
        <span class="keyword">int</span> sum = arr[left] + arr[right];
        <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> {left, right};
        <span class="keyword">else if</span> (sum < target) left++;
        <span class="keyword">else</span> right--;
    }
    <span class="keyword">return</span> {};
}

<span class="comment">// Sliding Window</span>
<span class="keyword">int</span> <span class="function">maxSumSubarray</span>(vector&lt;<span class="keyword">int</span>&gt;& arr, <span class="keyword">int</span> k) {
    <span class="keyword">if</span> (arr.size() < k) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> windowSum = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < k; i++) windowSum += arr[i];
    <span class="keyword">int</span> maxSum = windowSum;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i < arr.size(); i++) {
        windowSum += arr[i] - arr[i - k];
        maxSum = max(maxSum, windowSum);
    }
    <span class="keyword">return</span> maxSum;
}</code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <!-- Two Sum -->
                    <div class="problem-item" data-pattern="hash-map" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">1. Two Sum</span><span class="pattern-tag">hash-map</span>
                            <a href="https://leetcode.com/problems/two-sum/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
                            <p><strong>Pattern:</strong> Hash Map for O(1) lookup</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Brute Force First:</strong> Check every pair - O(n¬≤). Can we do better?</li>
                                    <li><strong>Key Insight:</strong> For each number, we need its complement (target - num). How to find it fast?</li>
                                    <li><strong>Hash Map!</strong> Store seen numbers with their indices. O(1) lookup for complement.</li>
                                    <li><strong>One Pass:</strong> As we iterate, check if complement exists, then add current to map.</li>
                                </ol>
                            </div>


                            <div class="code-tabs">
                                <button class="code-tab active" onclick="switchTab(this, 'twosum-py')">Python</button>
                                <button class="code-tab" onclick="switchTab(this, 'twosum-java')">Java</button>
                                <button class="code-tab" onclick="switchTab(this, 'twosum-cpp')">C++</button>
                            </div>
                            <div class="code-block">
                                <code class="code-content active" id="twosum-py"><span class="keyword">def</span> <span class="function">twoSum</span>(nums, target):
    <span class="comment"># Hash map to store value -> index</span>
    seen = {}
    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="keyword">enumerate</span>(nums):
        complement = target - num
        <span class="keyword">if</span> complement <span class="keyword">in</span> seen:
            <span class="keyword">return</span> [seen[complement], i]
        seen[num] = i
    <span class="keyword">return</span> []

<span class="comment"># Time: O(n), Space: O(n)</span></code>
                                <code class="code-content" id="twosum-java"><span class="keyword">public int</span>[] <span class="function">twoSum</span>(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {
    Map&lt;Integer, Integer&gt; seen = <span class="keyword">new</span> HashMap&lt;&gt;();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {
        <span class="keyword">int</span> complement = target - nums[i];
        <span class="keyword">if</span> (seen.containsKey(complement)) {
            <span class="keyword">return new int</span>[]{seen.get(complement), i};
        }
        seen.put(nums[i], i);
    }
    <span class="keyword">return new int</span>[]{};
}
<span class="comment">// Time: O(n), Space: O(n)</span></code>
                                <code class="code-content" id="twosum-cpp">vector&lt;<span class="keyword">int</span>&gt; <span class="function">twoSum</span>(vector&lt;<span class="keyword">int</span>&gt;& nums, <span class="keyword">int</span> target) {
    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; seen;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.size(); i++) {
        <span class="keyword">int</span> complement = target - nums[i];
        <span class="keyword">if</span> (seen.count(complement)) {
            <span class="keyword">return</span> {seen[complement], i};
        }
        seen[nums[i]] = i;
    }
    <span class="keyword">return</span> {};
}
<span class="comment">// Time: O(n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=KLlXCFG5TnA" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <!-- Best Time to Buy and Sell Stock -->
                    <div class="problem-item" data-pattern="array" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">121. Best Time to Buy and Sell Stock</span><span class="pattern-tag">array</span>
                            <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find the maximum profit from buying and selling a stock once.</p>
                            <p><strong>Pattern:</strong> Track minimum price seen so far, calculate max profit at each step</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>What do we need?</strong> Max difference where smaller comes before larger.</li>
                                    <li><strong>Track minimum:</strong> Keep track of minimum price seen so far.</li>
                                    <li><strong>Calculate profit:</strong> At each day, profit = current price - min so far.</li>
                                    <li><strong>Update max:</strong> Keep track of maximum profit seen.</li>
                                </ol>
                            </div>


                            <div class="code-tabs">
                                <button class="code-tab active" onclick="switchTab(this, 'stock-py')">Python</button>
                                <button class="code-tab" onclick="switchTab(this, 'stock-java')">Java</button>
                            </div>
                            <div class="code-block">
                                <code class="code-content active" id="stock-py"><span class="keyword">def</span> <span class="function">maxProfit</span>(prices):
    min_price = <span class="keyword">float</span>(<span class="string">'inf'</span>)
    max_profit = <span class="number">0</span>

    <span class="keyword">for</span> price <span class="keyword">in</span> prices:
        <span class="keyword">if</span> price < min_price:
            min_price = price
        <span class="keyword">elif</span> price - min_price > max_profit:
            max_profit = price - min_price

    <span class="keyword">return</span> max_profit

<span class="comment"># Time: O(n), Space: O(1)</span></code>
                                <code class="code-content" id="stock-java"><span class="keyword">public int</span> <span class="function">maxProfit</span>(<span class="keyword">int</span>[] prices) {
    <span class="keyword">int</span> minPrice = Integer.MAX_VALUE;
    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;

    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) {
        <span class="keyword">if</span> (price < minPrice) {
            minPrice = price;
        } <span class="keyword">else if</span> (price - minPrice > maxProfit) {
            maxProfit = price - minPrice;
        }
    }
    <span class="keyword">return</span> maxProfit;
}
<span class="comment">// Time: O(n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=1pkOgXD63yU" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <!-- Contains Duplicate -->
                    <div class="problem-item" data-pattern="hash-map" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">217. Contains Duplicate</span><span class="pattern-tag">hash-map</span>
                            <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Return true if any value appears at least twice in the array.</p>
                            <p><strong>Pattern:</strong> Use HashSet for O(1) duplicate detection</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Brute Force:</strong> Compare every pair - O(n¬≤). Too slow!</li>
                                    <li><strong>Sorting:</strong> Sort and check adjacent - O(n log n). Better!</li>
                                    <li><strong>Hash Set:</strong> Add elements to set, check if already exists - O(n). Best!</li>
                                    <li><strong>One-liner:</strong> Compare len(nums) vs len(set(nums)).</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">containsDuplicate</span>(nums):
    <span class="keyword">return len</span>(nums) != <span class="keyword">len</span>(<span class="keyword">set</span>(nums))

    <span class="comment"># Alternative with early exit:</span>
    <span class="comment"># seen = set()</span>
    <span class="comment"># for num in nums:</span>
    <span class="comment">#     if num in seen: return True</span>
    <span class="comment">#     seen.add(num)</span>
    <span class="comment"># return False</span>

<span class="comment"># Time: O(n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=3OamzN90kPg" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <!-- Maximum Subarray -->
                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">53. Maximum Subarray (Kadane's Algorithm)</span>
                            <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find the contiguous subarray with the largest sum.</p>
                            <p><strong>Pattern:</strong> Kadane's Algorithm - track current max and global max</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Brute Force:</strong> Check all subarrays - O(n¬≤). Can we optimize?</li>
                                    <li><strong>Key Decision:</strong> At each element, extend current subarray OR start fresh?</li>
                                    <li><strong>Kadane's Insight:</strong> current_sum = max(nums[i], current_sum + nums[i])</li>
                                    <li><strong>Track Global Max:</strong> Update max_sum whenever current_sum improves.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">maxSubArray</span>(nums):
    <span class="comment"># Kadane's Algorithm</span>
    max_sum = nums[<span class="number">0</span>]
    current_sum = nums[<span class="number">0</span>]

    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, <span class="keyword">len</span>(nums)):
        <span class="comment"># Either extend current subarray or start new one</span>
        current_sum = <span class="keyword">max</span>(nums[i], current_sum + nums[i])
        max_sum = <span class="keyword">max</span>(max_sum, current_sum)

    <span class="keyword">return</span> max_sum

<span class="comment"># Time: O(n), Space: O(1)</span>

<span class="comment"># Example: nums = [-2,1,-3,4,-1,2,1,-5,4]</span>
<span class="comment"># Answer: 6 (subarray [4,-1,2,1])</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=5WZl3MMT0Eg" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <!-- Product of Array Except Self -->
                    <div class="problem-item" data-pattern="array" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">238. Product of Array Except Self</span><span class="pattern-tag">array</span>
                            <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Return array where each element is product of all other elements (without using division).</p>
                            <p><strong>Pattern:</strong> Prefix and suffix products</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>With Division:</strong> Total product √∑ nums[i]. But division not allowed!</li>
                                    <li><strong>Key Insight:</strong> result[i] = (product of all left) √ó (product of all right)</li>
                                    <li><strong>Two Passes:</strong> First pass: left products. Second pass: multiply by right products.</li>
                                    <li><strong>Space Optimization:</strong> Use output array for left, variable for right.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">productExceptSelf</span>(nums):
    n = <span class="keyword">len</span>(nums)
    result = [<span class="number">1</span>] * n

    <span class="comment"># Left pass: multiply all elements to the left</span>
    left_product = <span class="number">1</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n):
        result[i] = left_product
        left_product *= nums[i]

    <span class="comment"># Right pass: multiply all elements to the right</span>
    right_product = <span class="number">1</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):
        result[i] *= right_product
        right_product *= nums[i]

    <span class="keyword">return</span> result

<span class="comment"># Time: O(n), Space: O(1) excluding output array</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=bNvIQI2wAjk" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Strings Section -->
        <section class="section" id="strings">
            <div class="section-header">
                <h2>üìù Strings</h2>
                <span class="badge badge-beginner">Beginner</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-strings" onchange="updateProgress()">
                    <label for="check-strings">Mark as completed</label>
                </div>

                <h3>What are Strings?</h3>
                <p>Strings are sequences of characters. In most languages, strings are immutable, meaning any modification creates a new string. Understanding string manipulation is crucial for text processing, parsing, and pattern matching.</p>

                <div class="complexity">
                    <span class="time">Access: O(1)</span>
                    <span class="time">Search: O(n)</span>
                    <span class="time">Concatenation: O(n)</span>
                    <span class="space">Space: O(n)</span>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Text editors:</strong> Search and replace, spell checking</li>
                        <li><strong>Web scraping:</strong> Parsing HTML/XML content</li>
                        <li><strong>Data validation:</strong> Email, phone number validation</li>
                        <li><strong>Compilers:</strong> Lexical analysis and tokenization</li>
                        <li><strong>DNA sequencing:</strong> Pattern matching in genetic data</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=aKjj4wpK33o" target="_blank" class="link-btn">üì∫ String Manipulation - CS Dojo</a>
                    <a href="https://www.youtube.com/watch?v=V5-7GzOfADQ" target="_blank" class="link-btn">üì∫ Strings in Python - Corey Schafer</a>
                </div>

                <h3>üíª Common String Operations</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'string-py')">Python</button>
                    <button class="code-tab" onclick="switchTab(this, 'string-java')">Java</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="string-py"><span class="comment"># Python String Operations</span>

s = <span class="string">"hello world"</span>

<span class="comment"># Common operations</span>
<span class="keyword">len</span>(s)              <span class="comment"># Length: 11</span>
s[<span class="number">0</span>]                <span class="comment"># Access: 'h'</span>
s[-<span class="number">1</span>]               <span class="comment"># Last char: 'd'</span>
s[<span class="number">0</span>:<span class="number">5</span>]              <span class="comment"># Slice: 'hello'</span>
s.upper()           <span class="comment"># 'HELLO WORLD'</span>
s.lower()           <span class="comment"># 'hello world'</span>
s.split()           <span class="comment"># ['hello', 'world']</span>
<span class="string">" "</span>.join([<span class="string">'a'</span>,<span class="string">'b'</span>]) <span class="comment"># 'a b'</span>
s.replace(<span class="string">'l'</span>,<span class="string">'x'</span>)  <span class="comment"># 'hexxo worxd'</span>
s.find(<span class="string">'world'</span>)     <span class="comment"># Index: 6</span>
s.count(<span class="string">'l'</span>)        <span class="comment"># Count: 3</span>
s.strip()           <span class="comment"># Remove whitespace</span>
s.isalnum()         <span class="comment"># Is alphanumeric?</span>

<span class="comment"># String reversal</span>
reversed_s = s[::-<span class="number">1</span>]  <span class="comment"># 'dlrow olleh'</span>

<span class="comment"># Check palindrome</span>
<span class="keyword">def</span> <span class="function">is_palindrome</span>(s):
    s = s.lower()
    <span class="keyword">return</span> s == s[::-<span class="number">1</span>]

<span class="comment"># Character frequency</span>
<span class="keyword">from</span> collections <span class="keyword">import</span> Counter
freq = Counter(s)  <span class="comment"># {'l': 3, 'o': 2, ...}</span></code>
                    <code class="code-content" id="string-java"><span class="comment">// Java String Operations</span>

String s = <span class="string">"hello world"</span>;

<span class="comment">// Common operations</span>
s.length();              <span class="comment">// Length: 11</span>
s.charAt(<span class="number">0</span>);             <span class="comment">// Access: 'h'</span>
s.substring(<span class="number">0</span>, <span class="number">5</span>);       <span class="comment">// Slice: "hello"</span>
s.toUpperCase();         <span class="comment">// "HELLO WORLD"</span>
s.toLowerCase();         <span class="comment">// "hello world"</span>
s.split(<span class="string">" "</span>);            <span class="comment">// ["hello", "world"]</span>
String.join(<span class="string">" "</span>, arr);   <span class="comment">// Join array</span>
s.replace(<span class="string">'l'</span>, <span class="string">'x'</span>);    <span class="comment">// "hexxo worxd"</span>
s.indexOf(<span class="string">"world"</span>);      <span class="comment">// Index: 6</span>
s.trim();                <span class="comment">// Remove whitespace</span>

<span class="comment">// StringBuilder for mutations</span>
StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);
sb.reverse();            <span class="comment">// "dlrow olleh"</span>
sb.append(<span class="string">"!"</span>);

<span class="comment">// Check palindrome</span>
<span class="keyword">public boolean</span> <span class="function">isPalindrome</span>(String s) {
    s = s.toLowerCase();
    <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;
    <span class="keyword">while</span> (l < r) {
        <span class="keyword">if</span> (s.charAt(l++) != s.charAt(r--))
            <span class="keyword">return false</span>;
    }
    <span class="keyword">return true</span>;
}</code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <!-- Valid Palindrome -->
                    <div class="problem-item" data-pattern="two-pointers" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">125. Valid Palindrome</span><span class="pattern-tag">two-pointers</span>
                            <a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Check if a string is a palindrome, considering only alphanumeric characters.</p>
                            <p><strong>Pattern:</strong> Two pointers from both ends</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Clean First:</strong> Remove non-alphanumeric, convert to lowercase.</li>
                                    <li><strong>Two Pointers:</strong> Compare from both ends moving inward.</li>
                                    <li><strong>Alternative:</strong> Compare string with its reverse.</li>
                                    <li><strong>Edge Cases:</strong> Empty string, single character = valid palindrome.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">isPalindrome</span>(s):
    left, right = <span class="number">0</span>, <span class="keyword">len</span>(s) - <span class="number">1</span>

    <span class="keyword">while</span> left < right:
        <span class="comment"># Skip non-alphanumeric</span>
        <span class="keyword">while</span> left < right <span class="keyword">and not</span> s[left].isalnum():
            left += <span class="number">1</span>
        <span class="keyword">while</span> left < right <span class="keyword">and not</span> s[right].isalnum():
            right -= <span class="number">1</span>

        <span class="keyword">if</span> s[left].lower() != s[right].lower():
            <span class="keyword">return False</span>

        left += <span class="number">1</span>
        right -= <span class="number">1</span>

    <span class="keyword">return True</span>

<span class="comment"># Time: O(n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=jJXJ16kPFWg" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <!-- Valid Anagram -->
                    <div class="problem-item" data-pattern="hash-map" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">242. Valid Anagram</span><span class="pattern-tag">hash-map</span>
                            <a href="https://leetcode.com/problems/valid-anagram/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Check if two strings are anagrams of each other.</p>
                            <p><strong>Pattern:</strong> Character frequency counting</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>What's an anagram?</strong> Same characters, same frequencies, different order.</li>
                                    <li><strong>Sorting Approach:</strong> Sort both strings, compare - O(n log n).</li>
                                    <li><strong>Hash Map:</strong> Count chars in first, decrement with second - O(n).</li>
                                    <li><strong>Python Trick:</strong> Counter(s) == Counter(t) one-liner!</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">isAnagram</span>(s, t):
    <span class="keyword">if len</span>(s) != <span class="keyword">len</span>(t):
        <span class="keyword">return False</span>

    <span class="comment"># Method 1: Counter</span>
    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter
    <span class="keyword">return</span> Counter(s) == Counter(t)

    <span class="comment"># Method 2: Array for lowercase letters</span>
    <span class="comment"># count = [0] * 26</span>
    <span class="comment"># for i in range(len(s)):</span>
    <span class="comment">#     count[ord(s[i]) - ord('a')] += 1</span>
    <span class="comment">#     count[ord(t[i]) - ord('a')] -= 1</span>
    <span class="comment"># return all(c == 0 for c in count)</span>

<span class="comment"># Time: O(n), Space: O(1) - fixed 26 chars</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=9UtInBqnCgA" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <!-- Longest Substring Without Repeating -->
                    <div class="problem-item" data-pattern="sliding-window" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">3. Longest Substring Without Repeating Characters</span><span class="pattern-tag">sliding-window</span>
                            <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find the length of the longest substring without repeating characters.</p>
                            <p><strong>Pattern:</strong> Sliding Window with HashSet</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Brute Force:</strong> Check all substrings - O(n¬≥). Way too slow!</li>
                                    <li><strong>Sliding Window:</strong> Expand right, shrink left when duplicate found.</li>
                                    <li><strong>Track Characters:</strong> Use set or hash map for O(1) duplicate check.</li>
                                    <li><strong>Optimization:</strong> Jump left pointer directly to after duplicate's position.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">lengthOfLongestSubstring</span>(s):
    char_set = <span class="keyword">set</span>()
    left = <span class="number">0</span>
    max_length = <span class="number">0</span>

    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">len</span>(s)):
        <span class="comment"># Shrink window until no duplicate</span>
        <span class="keyword">while</span> s[right] <span class="keyword">in</span> char_set:
            char_set.remove(s[left])
            left += <span class="number">1</span>

        char_set.add(s[right])
        max_length = <span class="keyword">max</span>(max_length, right - left + <span class="number">1</span>)

    <span class="keyword">return</span> max_length

<span class="comment"># Time: O(n), Space: O(min(m, n)) - m is charset size</span>

<span class="comment"># Example: "abcabcbb" ‚Üí 3 ("abc")</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=wiGpQwVHdE0" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <!-- Group Anagrams -->
                    <div class="problem-item" data-pattern="hash-map" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">49. Group Anagrams</span><span class="pattern-tag">hash-map</span>
                            <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Group strings that are anagrams of each other.</p>
                            <p><strong>Pattern:</strong> Hash map with sorted string or char count as key</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Anagram Property:</strong> All anagrams have same sorted string.</li>
                                    <li><strong>Hash Map Key:</strong> Use sorted string as key to group anagrams.</li>
                                    <li><strong>Alternative Key:</strong> Tuple of character counts (faster for long strings).</li>
                                    <li><strong>Build Groups:</strong> Iterate once, append to appropriate group.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">groupAnagrams</span>(strs):
    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict

    anagram_map = defaultdict(<span class="keyword">list</span>)

    <span class="keyword">for</span> s <span class="keyword">in</span> strs:
        <span class="comment"># Use sorted string as key</span>
        key = <span class="keyword">tuple</span>(<span class="keyword">sorted</span>(s))
        anagram_map[key].append(s)

    <span class="keyword">return list</span>(anagram_map.values())

<span class="comment"># Alternative: Use character count as key</span>
<span class="keyword">def</span> <span class="function">groupAnagrams2</span>(strs):
    anagram_map = defaultdict(<span class="keyword">list</span>)

    <span class="keyword">for</span> s <span class="keyword">in</span> strs:
        count = [<span class="number">0</span>] * <span class="number">26</span>
        <span class="keyword">for</span> c <span class="keyword">in</span> s:
            count[<span class="keyword">ord</span>(c) - <span class="keyword">ord</span>(<span class="string">'a'</span>)] += <span class="number">1</span>
        anagram_map[<span class="keyword">tuple</span>(count)].append(s)

    <span class="keyword">return list</span>(anagram_map.values())

<span class="comment"># Time: O(n * k log k) or O(n * k), Space: O(n * k)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=vzdNOK2oB2E" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Sorting Algorithms Section -->
        <section class="section" id="sorting">
            <div class="section-header">
                <h2>üîÑ Sorting Algorithms</h2>
                <span class="badge badge-beginner">Beginner</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-sorting" onchange="updateProgress()">
                    <label for="check-sorting">Mark as completed</label>
                </div>

                <h3>Understanding Sorting</h3>
                <p>Sorting algorithms arrange elements in a specific order. Understanding different sorting algorithms helps in choosing the right one based on data characteristics, time constraints, and space limitations.</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>Bubble Sort</h4>
                        <div class="complexity">
                            <span class="time">Time: O(n¬≤)</span>
                            <span class="space">Space: O(1)</span>
                        </div>
                        <p>Simple but inefficient. Repeatedly swaps adjacent elements if in wrong order.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Selection Sort</h4>
                        <div class="complexity">
                            <span class="time">Time: O(n¬≤)</span>
                            <span class="space">Space: O(1)</span>
                        </div>
                        <p>Finds minimum element and places it at beginning. Good for small arrays.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Insertion Sort</h4>
                        <div class="complexity">
                            <span class="time">Time: O(n¬≤)</span>
                            <span class="space">Space: O(1)</span>
                        </div>
                        <p>Builds sorted array one element at a time. Efficient for small or nearly sorted data.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Merge Sort</h4>
                        <div class="complexity">
                            <span class="time">Time: O(n log n)</span>
                            <span class="space">Space: O(n)</span>
                        </div>
                        <p>Divide and conquer. Stable sort. Great for linked lists.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Quick Sort</h4>
                        <div class="complexity">
                            <span class="time">Time: O(n log n) avg</span>
                            <span class="space">Space: O(log n)</span>
                        </div>
                        <p>Divide and conquer with pivot. In-place. Most used in practice.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Heap Sort</h4>
                        <div class="complexity">
                            <span class="time">Time: O(n log n)</span>
                            <span class="space">Space: O(1)</span>
                        </div>
                        <p>Uses heap data structure. In-place but not stable.</p>
                    </div>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Database indexing:</strong> B-trees use sorted data for efficient queries</li>
                        <li><strong>Search engines:</strong> Ranking search results by relevance</li>
                        <li><strong>E-commerce:</strong> Sorting products by price, rating, popularity</li>
                        <li><strong>Operating systems:</strong> Process scheduling, file management</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=kPRA0W1kECg" target="_blank" class="link-btn">üì∫ Sorting Algorithms - CS50</a>
                    <a href="https://www.youtube.com/watch?v=MtQL_ll5KhQ" target="_blank" class="link-btn">üì∫ Merge Sort - Abdul Bari</a>
                    <a href="https://www.youtube.com/watch?v=7h1s2SojIRw" target="_blank" class="link-btn">üì∫ Quick Sort - Abdul Bari</a>
                </div>

                <h3>üíª Implementations</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'sort-merge')">Merge Sort</button>
                    <button class="code-tab" onclick="switchTab(this, 'sort-quick')">Quick Sort</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="sort-merge"><span class="comment"># Merge Sort - O(n log n) time, O(n) space</span>

<span class="keyword">def</span> <span class="function">mergeSort</span>(arr):
    <span class="keyword">if len</span>(arr) <= <span class="number">1</span>:
        <span class="keyword">return</span> arr

    mid = <span class="keyword">len</span>(arr) // <span class="number">2</span>
    left = mergeSort(arr[:mid])
    right = mergeSort(arr[mid:])

    <span class="keyword">return</span> merge(left, right)

<span class="keyword">def</span> <span class="function">merge</span>(left, right):
    result = []
    i = j = <span class="number">0</span>

    <span class="keyword">while</span> i < <span class="keyword">len</span>(left) <span class="keyword">and</span> j < <span class="keyword">len</span>(right):
        <span class="keyword">if</span> left[i] <= right[j]:
            result.append(left[i])
            i += <span class="number">1</span>
        <span class="keyword">else</span>:
            result.append(right[j])
            j += <span class="number">1</span>

    result.extend(left[i:])
    result.extend(right[j:])
    <span class="keyword">return</span> result

<span class="comment"># Stable sort - maintains relative order of equal elements</span>
<span class="comment"># Best for: Linked lists, external sorting, stable sorting needs</span></code>
                    <code class="code-content" id="sort-quick"><span class="comment"># Quick Sort - O(n log n) avg, O(n¬≤) worst, O(log n) space</span>

<span class="keyword">def</span> <span class="function">quickSort</span>(arr, low=<span class="number">0</span>, high=<span class="keyword">None</span>):
    <span class="keyword">if</span> high <span class="keyword">is None</span>:
        high = <span class="keyword">len</span>(arr) - <span class="number">1</span>

    <span class="keyword">if</span> low < high:
        pivot_idx = partition(arr, low, high)
        quickSort(arr, low, pivot_idx - <span class="number">1</span>)
        quickSort(arr, pivot_idx + <span class="number">1</span>, high)

    <span class="keyword">return</span> arr

<span class="keyword">def</span> <span class="function">partition</span>(arr, low, high):
    pivot = arr[high]  <span class="comment"># Choose rightmost as pivot</span>
    i = low - <span class="number">1</span>

    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(low, high):
        <span class="keyword">if</span> arr[j] <= pivot:
            i += <span class="number">1</span>
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]
    <span class="keyword">return</span> i + <span class="number">1</span>

<span class="comment"># In-place sort - uses O(log n) stack space</span>
<span class="comment"># Best for: Arrays, when average case matters, cache efficiency</span></code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="array" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">912. Sort an Array</span><span class="pattern-tag">array</span>
                            <a href="https://leetcode.com/problems/sort-an-array/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Sort an array without using built-in sort functions.</p>
                            <p><strong>Pattern:</strong> Implement Merge Sort for O(n log n) guaranteed performance</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>No Built-in:</strong> Must implement sorting algorithm ourselves.</li>
                                    <li><strong>Merge Sort:</strong> Divide in half, sort each, merge - O(n log n) guaranteed.</li>
                                    <li><strong>Quick Sort:</strong> Partition around pivot - O(n log n) average, O(n¬≤) worst.</li>
                                    <li><strong>Choice:</strong> Merge sort for stability, Quick sort for in-place.</li>
                                </ol>
                            </div>

                            <p><strong>üí° Key Insight:</strong> Merge Sort divides array in half, recursively sorts each half, then merges. QuickSort is faster on average but has O(n¬≤) worst case.</p>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">sortArray</span>(nums):
    <span class="comment"># Merge Sort Implementation</span>
    <span class="keyword">if len</span>(nums) <= <span class="number">1</span>:
        <span class="keyword">return</span> nums
    
    mid = <span class="keyword">len</span>(nums) // <span class="number">2</span>
    left = sortArray(nums[:mid])
    right = sortArray(nums[mid:])
    
    <span class="keyword">return</span> merge(left, right)

<span class="keyword">def</span> <span class="function">merge</span>(left, right):
    result = []
    i = j = <span class="number">0</span>
    
    <span class="keyword">while</span> i < <span class="keyword">len</span>(left) <span class="keyword">and</span> j < <span class="keyword">len</span>(right):
        <span class="keyword">if</span> left[i] <= right[j]:
            result.append(left[i])
            i += <span class="number">1</span>
        <span class="keyword">else</span>:
            result.append(right[j])
            j += <span class="number">1</span>
    
    result.extend(left[i:])
    result.extend(right[j:])
    <span class="keyword">return</span> result

<span class="comment"># Time: O(n log n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=MsYZSinhuFo" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">75. Sort Colors (Dutch National Flag)</span>
                            <a href="https://leetcode.com/problems/sort-colors/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Sort array containing only 0, 1, and 2 in one pass.</p>
                            <p><strong>Pattern:</strong> Three-way partitioning</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Counting Sort:</strong> Count 0s, 1s, 2s then overwrite - 2 passes.</li>
                                    <li><strong>One Pass:</strong> Three pointers - low, mid, high.</li>
                                    <li><strong>Dutch Flag:</strong> 0s go to low, 2s go to high, 1s stay in middle.</li>
                                    <li><strong>Swap Logic:</strong> mid encounters 0‚Üíswap with low, 2‚Üíswap with high.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">sortColors</span>(nums):
    <span class="comment"># Dutch National Flag Algorithm</span>
    low, mid, high = <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">len</span>(nums) - <span class="number">1</span>

    <span class="keyword">while</span> mid <= high:
        <span class="keyword">if</span> nums[mid] == <span class="number">0</span>:
            nums[low], nums[mid] = nums[mid], nums[low]
            low += <span class="number">1</span>
            mid += <span class="number">1</span>
        <span class="keyword">elif</span> nums[mid] == <span class="number">1</span>:
            mid += <span class="number">1</span>
        <span class="keyword">else</span>:  <span class="comment"># nums[mid] == 2</span>
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= <span class="number">1</span>

<span class="comment"># Time: O(n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=4xbWSRZHqac" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="array" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">56. Merge Intervals</span><span class="pattern-tag">array</span>
                            <a href="https://leetcode.com/problems/merge-intervals/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Merge all overlapping intervals.</p>
                            <p><strong>Pattern:</strong> Sort by start time, then merge</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Sort First:</strong> Sort by start time to process in order.</li>
                                    <li><strong>Overlap Check:</strong> Current start ‚â§ previous end means overlap.</li>
                                    <li><strong>Merge:</strong> Extend end to max(prev end, curr end).</li>
                                    <li><strong>No Overlap:</strong> Add previous to result, start new interval.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">merge</span>(intervals):
    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])
    merged = [intervals[<span class="number">0</span>]]

    <span class="keyword">for</span> current <span class="keyword">in</span> intervals[<span class="number">1</span>:]:
        last = merged[-<span class="number">1</span>]

        <span class="keyword">if</span> current[<span class="number">0</span>] <= last[<span class="number">1</span>]:  <span class="comment"># Overlapping</span>
            last[<span class="number">1</span>] = <span class="keyword">max</span>(last[<span class="number">1</span>], current[<span class="number">1</span>])
        <span class="keyword">else</span>:
            merged.append(current)

    <span class="keyword">return</span> merged

<span class="comment"># Time: O(n log n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=44H3cEC2fFM" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Searching Section -->
        <section class="section" id="searching">
            <div class="section-header">
                <h2>üîç Searching Algorithms</h2>
                <span class="badge badge-beginner">Beginner</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-searching" onchange="updateProgress()">
                    <label for="check-searching">Mark as completed</label>
                </div>

                <h3>Linear vs Binary Search</h3>
                <p>Linear search checks each element sequentially (O(n)), while binary search divides the search space in half each time (O(log n)), but requires sorted data.</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>Linear Search</h4>
                        <div class="complexity">
                            <span class="time">Time: O(n)</span>
                            <span class="space">Space: O(1)</span>
                        </div>
                        <p>Works on unsorted data. Check each element one by one.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Binary Search</h4>
                        <div class="complexity">
                            <span class="time">Time: O(log n)</span>
                            <span class="space">Space: O(1)</span>
                        </div>
                        <p>Requires sorted data. Divides search space in half each iteration.</p>
                    </div>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Database queries:</strong> Finding records with indexed columns</li>
                        <li><strong>Git bisect:</strong> Finding bug-introducing commits</li>
                        <li><strong>Dictionary lookup:</strong> Word search in sorted dictionary</li>
                        <li><strong>System libraries:</strong> Arrays.binarySearch(), bisect module</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=P3YID7liBug" target="_blank" class="link-btn">üì∫ Binary Search - CS50</a>
                    <a href="https://www.youtube.com/watch?v=GU7DpgHINWQ" target="_blank" class="link-btn">üì∫ Binary Search - Abdul Bari</a>
                </div>

                <h3>üíª Binary Search Template</h3>
                <div class="code-block">
                    <code class="code-content active"><span class="comment"># Standard Binary Search</span>
<span class="keyword">def</span> <span class="function">binarySearch</span>(arr, target):
    left, right = <span class="number">0</span>, <span class="keyword">len</span>(arr) - <span class="number">1</span>

    <span class="keyword">while</span> left <= right:
        mid = left + (right - left) // <span class="number">2</span>  <span class="comment"># Avoid overflow</span>

        <span class="keyword">if</span> arr[mid] == target:
            <span class="keyword">return</span> mid
        <span class="keyword">elif</span> arr[mid] < target:
            left = mid + <span class="number">1</span>
        <span class="keyword">else</span>:
            right = mid - <span class="number">1</span>

    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># Not found</span>

<span class="comment"># Find leftmost (first) occurrence</span>
<span class="keyword">def</span> <span class="function">findFirst</span>(arr, target):
    left, right = <span class="number">0</span>, <span class="keyword">len</span>(arr) - <span class="number">1</span>
    result = -<span class="number">1</span>

    <span class="keyword">while</span> left <= right:
        mid = left + (right - left) // <span class="number">2</span>
        <span class="keyword">if</span> arr[mid] == target:
            result = mid
            right = mid - <span class="number">1</span>  <span class="comment"># Keep searching left</span>
        <span class="keyword">elif</span> arr[mid] < target:
            left = mid + <span class="number">1</span>
        <span class="keyword">else</span>:
            right = mid - <span class="number">1</span>

    <span class="keyword">return</span> result

<span class="comment"># Binary search on answer (when searching in a range)</span>
<span class="keyword">def</span> <span class="function">binarySearchOnAnswer</span>(low, high, condition):
    <span class="keyword">while</span> low < high:
        mid = low + (high - low) // <span class="number">2</span>
        <span class="keyword">if</span> condition(mid):
            high = mid  <span class="comment"># Answer could be mid or smaller</span>
        <span class="keyword">else</span>:
            low = mid + <span class="number">1</span>  <span class="comment"># Answer must be larger</span>
    <span class="keyword">return</span> low</code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="binary-search" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">704. Binary Search</span><span class="pattern-tag">binary-search</span>
                            <a href="https://leetcode.com/problems/binary-search/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Given a sorted array and target, return index if found, else -1.</p>
                            <p><strong>Pattern:</strong> Classic Binary Search - divide search space in half each iteration</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Prerequisite:</strong> Array must be sorted!</li>
                                    <li><strong>Core Idea:</strong> Compare with middle, eliminate half each time.</li>
                                    <li><strong>Boundaries:</strong> left = 0, right = len-1. Update based on comparison.</li>
                                    <li><strong>Termination:</strong> left > right means element not found.</li>
                                </ol>
                            </div>

                            <p><strong>üí° Key Insight:</strong> Compare target with middle element. If target is smaller, search left half; if larger, search right half.</p>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">search</span>(nums, target):
    left, right = <span class="number">0</span>, <span class="keyword">len</span>(nums) - <span class="number">1</span>
    
    <span class="keyword">while</span> left <= right:
        mid = (left + right) // <span class="number">2</span>  <span class="comment"># or left + (right - left) // 2 to avoid overflow</span>
        
        <span class="keyword">if</span> nums[mid] == target:
            <span class="keyword">return</span> mid
        <span class="keyword">elif</span> nums[mid] < target:
            left = mid + <span class="number">1</span>   <span class="comment"># Target in right half</span>
        <span class="keyword">else</span>:
            right = mid - <span class="number">1</span>  <span class="comment"># Target in left half</span>
    
    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># Target not found</span>

<span class="comment"># Time: O(log n), Space: O(1)</span>

<span class="comment"># Example: nums = [-1,0,3,5,9,12], target = 9</span>
<span class="comment"># Step 1: mid=2, nums[2]=3 < 9, search right</span>
<span class="comment"># Step 2: mid=4, nums[4]=9 == 9, return 4</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=s4DPM8ct1pI" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="binary-search" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">33. Search in Rotated Sorted Array</span><span class="pattern-tag">binary-search</span>
                            <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Search in a sorted array that has been rotated.</p>
                            <p><strong>Pattern:</strong> Modified binary search - identify sorted half</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Challenge:</strong> Array is rotated, but still partially sorted.</li>
                                    <li><strong>Key Insight:</strong> One half is always sorted!</li>
                                    <li><strong>Identify Sorted Half:</strong> Compare nums[left] with nums[mid].</li>
                                    <li><strong>Decide Direction:</strong> Check if target is in sorted half, move accordingly.</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">search</span>(nums, target):
    left, right = <span class="number">0</span>, <span class="keyword">len</span>(nums) - <span class="number">1</span>

    <span class="keyword">while</span> left <= right:
        mid = (left + right) // <span class="number">2</span>

        <span class="keyword">if</span> nums[mid] == target:
            <span class="keyword">return</span> mid

        <span class="comment"># Left half is sorted</span>
        <span class="keyword">if</span> nums[left] <= nums[mid]:
            <span class="keyword">if</span> nums[left] <= target < nums[mid]:
                right = mid - <span class="number">1</span>
            <span class="keyword">else</span>:
                left = mid + <span class="number">1</span>
        <span class="comment"># Right half is sorted</span>
        <span class="keyword">else</span>:
            <span class="keyword">if</span> nums[mid] < target <= nums[right]:
                left = mid + <span class="number">1</span>
            <span class="keyword">else</span>:
                right = mid - <span class="number">1</span>

    <span class="keyword">return</span> -<span class="number">1</span>

<span class="comment"># Time: O(log n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=U8XENwh8Oy8" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="binary-search" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">153. Find Minimum in Rotated Sorted Array</span><span class="pattern-tag">binary-search</span>
                            <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find minimum element in rotated sorted array.</p>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">findMin</span>(nums):
    left, right = <span class="number">0</span>, <span class="keyword">len</span>(nums) - <span class="number">1</span>

    <span class="keyword">while</span> left < right:
        mid = (left + right) // <span class="number">2</span>

        <span class="keyword">if</span> nums[mid] > nums[right]:
            <span class="comment"># Min is in right half</span>
            left = mid + <span class="number">1</span>
        <span class="keyword">else</span>:
            <span class="comment"># Min is in left half (including mid)</span>
            right = mid

    <span class="keyword">return</span> nums[left]

<span class="comment"># Time: O(log n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=nIVW4P8b1VA" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="binary-search" data-difficulty="hard"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">4. Median of Two Sorted Arrays</span><span class="pattern-tag">binary-search</span>
                            <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find median of two sorted arrays in O(log(m+n)) time.</p>
                            <p><strong>Pattern:</strong> Binary search on partition</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Observation:</strong> Minimum is at the rotation point.</li>
                                    <li><strong>Binary Search:</strong> Compare mid with right to find unsorted half.</li>
                                    <li><strong>If nums[mid] > nums[right]:</strong> Min is in right half.</li>
                                    <li><strong>Otherwise:</strong> Min is in left half (including mid).</li>
                                </ol>
                            </div>


                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">findMedianSortedArrays</span>(nums1, nums2):
    <span class="comment"># Ensure nums1 is smaller</span>
    <span class="keyword">if len</span>(nums1) > <span class="keyword">len</span>(nums2):
        nums1, nums2 = nums2, nums1

    m, n = <span class="keyword">len</span>(nums1), <span class="keyword">len</span>(nums2)
    left, right = <span class="number">0</span>, m

    <span class="keyword">while</span> left <= right:
        partitionX = (left + right) // <span class="number">2</span>
        partitionY = (m + n + <span class="number">1</span>) // <span class="number">2</span> - partitionX

        maxLeftX = <span class="keyword">float</span>(<span class="string">'-inf'</span>) <span class="keyword">if</span> partitionX == <span class="number">0</span> <span class="keyword">else</span> nums1[partitionX - <span class="number">1</span>]
        minRightX = <span class="keyword">float</span>(<span class="string">'inf'</span>) <span class="keyword">if</span> partitionX == m <span class="keyword">else</span> nums1[partitionX]
        maxLeftY = <span class="keyword">float</span>(<span class="string">'-inf'</span>) <span class="keyword">if</span> partitionY == <span class="number">0</span> <span class="keyword">else</span> nums2[partitionY - <span class="number">1</span>]
        minRightY = <span class="keyword">float</span>(<span class="string">'inf'</span>) <span class="keyword">if</span> partitionY == n <span class="keyword">else</span> nums2[partitionY]

        <span class="keyword">if</span> maxLeftX <= minRightY <span class="keyword">and</span> maxLeftY <= minRightX:
            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">0</span>:
                <span class="keyword">return</span> (<span class="keyword">max</span>(maxLeftX, maxLeftY) + <span class="keyword">min</span>(minRightX, minRightY)) / <span class="number">2</span>
            <span class="keyword">else</span>:
                <span class="keyword">return max</span>(maxLeftX, maxLeftY)
        <span class="keyword">elif</span> maxLeftX > minRightY:
            right = partitionX - <span class="number">1</span>
        <span class="keyword">else</span>:
            left = partitionX + <span class="number">1</span>

<span class="comment"># Time: O(log(min(m,n))), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=q6IEA26hvXc" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- INTERMEDIATE LEVEL -->
        <!-- Sliding Window -->
        <section class="section" id="sliding-window">
            <div class="section-header">
                <h2>ü™ü Sliding Window</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <h3>What is Sliding Window?</h3>
                <p>A technique for processing sequential data by maintaining a "window" that slides through the array/string. Used when you need to find subarrays or substrings that satisfy certain conditions.</p>

                <div class="applications">
                    <h5>üåç When to Use Sliding Window</h5>
                    <ul>
                        <li><strong>Fixed Window:</strong> "Find max sum of k consecutive elements"</li>
                        <li><strong>Variable Window:</strong> "Longest substring with at most k distinct chars"</li>
                        <li><strong>Keywords:</strong> "subarray", "substring", "consecutive", "contiguous"</li>
                    </ul>
                </div>

                <h3>ÔøΩÔøΩ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=MK-NZ4hN7rs" target="_blank" class="link-btn">üì∫ NeetCode - Sliding Window</a>
                    <a href="https://www.youtube.com/watch?v=jM2dhDPYMQM" target="_blank" class="link-btn">üì∫ Tech Dose - Sliding Window</a>
                </div>

                <h3>üíª Sliding Window Template</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'slidingwindow-py')">Python</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="slidingwindow-py"><span class="comment"># Variable size sliding window template</span>
<span class="keyword">def</span> <span class="function">sliding_window</span>(arr):
    left = <span class="number">0</span>
    result = <span class="number">0</span>
    window_state = {}  <span class="comment"># or any state you need</span>
    
    <span class="keyword">for</span> right <span class="keyword">in</span> range(len(arr)):
        <span class="comment"># Expand: add arr[right] to window</span>
        
        <span class="keyword">while</span> window_is_invalid():
            <span class="comment"># Shrink: remove arr[left] from window</span>
            left += <span class="number">1</span>
        
        <span class="comment"># Update result (depends on problem)</span>
        result = max(result, right - left + <span class="number">1</span>)
    
    <span class="keyword">return</span> result

<span class="comment"># Time: O(n), Space: O(k) where k is window state size</span></code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="sliding-window" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">3. Longest Substring Without Repeating Characters</span>
                            <span class="pattern-tag">sliding-window</span>
                            <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find the length of the longest substring without repeating characters.</p>
                            <p><strong>Pattern:</strong> Variable Sliding Window + Hash Set</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Variable Window:</strong> Window size changes based on duplicates.</li>
                                    <li><strong>Expand:</strong> Add char to set, move right.</li>
                                    <li><strong>Shrink:</strong> When duplicate found, remove from left until valid.</li>
                                    <li><strong>Optimization:</strong> Use hash map to jump left pointer directly.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="sliding-window" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">424. Longest Repeating Character Replacement</span>
                            <span class="pattern-tag">sliding-window</span>
                            <a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find longest substring with same letters after at most k replacements.</p>
                            <p><strong>Pattern:</strong> Variable Sliding Window + Frequency Count</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Window Valid If:</strong> window_size - max_freq <= k</li>
                                    <li><strong>Track:</strong> Frequency of each char in window.</li>
                                    <li><strong>Shrink When:</strong> Need more than k replacements.</li>
                                    <li><strong>Trick:</strong> Don't need to update maxFreq when shrinking.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="sliding-window" data-difficulty="hard">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">76. Minimum Window Substring</span>
                            <span class="pattern-tag">sliding-window</span>
                            <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find minimum window in s that contains all characters of t.</p>
                            <p><strong>Pattern:</strong> Variable Sliding Window + Two Hash Maps</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Need Counter:</strong> Count required chars from t.</li>
                                    <li><strong>Have Counter:</strong> Track chars in current window.</li>
                                    <li><strong>Expand:</strong> Until window contains all chars of t.</li>
                                    <li><strong>Shrink:</strong> Minimize window while still valid.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Two Pointers -->
        <section class="section" id="two-pointers">
            <div class="section-header">
                <h2>üëÜüëÜ Two Pointers</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <h3>What are Two Pointers?</h3>
                <p>A technique using two pointers that traverse the data structure in a coordinated way. Common patterns: opposite ends moving inward, or same direction (fast/slow).</p>

                <div class="applications">
                    <h5>üåç Common Two Pointer Patterns</h5>
                    <ul>
                        <li><strong>Opposite Ends:</strong> Start from both ends, move inward (palindrome, two sum sorted)</li>
                        <li><strong>Fast & Slow:</strong> Detect cycles, find middle (linked list problems)</li>
                        <li><strong>Same Direction:</strong> Remove duplicates, merge arrays</li>
                    </ul>
                </div>

                <h3>üíª Two Pointers Templates</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'twoptr-py')">Python</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="twoptr-py"><span class="comment"># Pattern 1: Opposite ends (sorted array)</span>
<span class="keyword">def</span> <span class="function">two_sum_sorted</span>(arr, target):
    left, right = <span class="number">0</span>, len(arr) - <span class="number">1</span>
    <span class="keyword">while</span> left < right:
        curr_sum = arr[left] + arr[right]
        <span class="keyword">if</span> curr_sum == target:
            <span class="keyword">return</span> [left, right]
        <span class="keyword">elif</span> curr_sum < target:
            left += <span class="number">1</span>
        <span class="keyword">else</span>:
            right -= <span class="number">1</span>
    <span class="keyword">return</span> []

<span class="comment"># Pattern 2: Fast & Slow (cycle detection)</span>
<span class="keyword">def</span> <span class="function">has_cycle</span>(head):
    slow = fast = head
    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
        slow = slow.next
        fast = fast.next.next
        <span class="keyword">if</span> slow == fast:
            <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">return</span> <span class="keyword">False</span></code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="two-pointers" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">15. 3Sum</span>
                            <span class="pattern-tag">two-pointers</span>
                            <a href="https://leetcode.com/problems/3sum/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find all unique triplets that sum to zero.</p>
                            <p><strong>Pattern:</strong> Sort + Fix one + Two Pointers</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Sort First:</strong> Enables two pointer approach.</li>
                                    <li><strong>Fix One Element:</strong> Iterate i, then two sum on rest.</li>
                                    <li><strong>Skip Duplicates:</strong> Both for i and for left/right pointers.</li>
                                    <li><strong>Move Pointers:</strong> Sum too small? Move left. Too big? Move right.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="two-pointers" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">11. Container With Most Water</span>
                            <span class="pattern-tag">two-pointers</span>
                            <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find two lines that form container with most water.</p>
                            <p><strong>Pattern:</strong> Two Pointers from opposite ends</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Start Wide:</strong> Maximum width at left=0, right=n-1.</li>
                                    <li><strong>Area:</strong> min(height[left], height[right]) * (right - left)</li>
                                    <li><strong>Move Shorter:</strong> Moving taller can only decrease area.</li>
                                    <li><strong>Track Max:</strong> Update maximum area seen.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="two-pointers" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">42. Trapping Rain Water</span>
                            <span class="pattern-tag">two-pointers</span>
                            <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Calculate how much rainwater can be trapped.</p>
                            <p><strong>Pattern:</strong> Two Pointers with max tracking</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Water at i:</strong> min(maxLeft, maxRight) - height[i]</li>
                                    <li><strong>Track maxLeft, maxRight:</strong> Maximum heights seen from each side.</li>
                                    <li><strong>Move Smaller Side:</strong> Process the pointer with smaller max.</li>
                                    <li><strong>Why?</strong> Water level is limited by the smaller side.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <section class="section" id="intermediate">
            <div class="section-header">
                <h2>üåø Intermediate Level</h2>
                <span class="badge badge-intermediate">6-8 Weeks</span>
            </div>
            <div class="section-body">
                <p>Build upon fundamentals with more complex data structures. Learn to choose the right data structure for different problems and understand trade-offs between different approaches.</p>
            </div>
        </section>

        <!-- Linked Lists Section -->
        <section class="section" id="linkedlists">
            <div class="section-header">
                <h2>üîó Linked Lists</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-linkedlists" onchange="updateProgress()">
                    <label for="check-linkedlists">Mark as completed</label>
                </div>

                <h3>What are Linked Lists?</h3>
                <p>A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node. Unlike arrays, linked lists don't require contiguous memory and allow efficient insertions/deletions at any position.</p>

                <div class="complexity">
                    <span class="time">Access: O(n)</span>
                    <span class="time">Search: O(n)</span>
                    <span class="time">Insert: O(1)*</span>
                    <span class="time">Delete: O(1)*</span>
                    <span class="space">Space: O(n)</span>
                </div>
                <p style="font-size: 0.85rem; color: var(--text-muted);">* O(1) when you have reference to the node, O(n) to find the node first</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>Singly Linked List</h4>
                        <p>Each node has data and a pointer to the next node. Simple but can only traverse forward.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Doubly Linked List</h4>
                        <p>Each node has pointers to both next and previous nodes. Allows bidirectional traversal.</p>
                    </div>
                    <div class="topic-card">
                        <h4>Circular Linked List</h4>
                        <p>Last node points back to the first node. Useful for round-robin scheduling.</p>
                    </div>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Browser history:</strong> Back/forward navigation (doubly linked)</li>
                        <li><strong>Music playlists:</strong> Previous/next song navigation</li>
                        <li><strong>Undo functionality:</strong> Text editors, design software</li>
                        <li><strong>Memory allocation:</strong> Free memory block management</li>
                        <li><strong>Hash table chaining:</strong> Collision resolution</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=F8AbOfQwl1c" target="_blank" class="link-btn">üì∫ Linked Lists - CS50</a>
                    <a href="https://www.youtube.com/watch?v=njTh_OwMljA" target="_blank" class="link-btn">üì∫ Linked List - HackerRank</a>
                </div>

                <h3>üíª Implementation</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'll-py')">Python</button>
                    <button class="code-tab" onclick="switchTab(this, 'll-java')">Java</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="ll-py"><span class="comment"># Singly Linked List Implementation</span>

<span class="keyword">class</span> <span class="class-name">ListNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, val=<span class="number">0</span>, next=<span class="keyword">None</span>):
        self.val = val
        self.next = next

<span class="keyword">class</span> <span class="class-name">LinkedList</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.head = <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">append</span>(self, val):
        <span class="keyword">if not</span> self.head:
            self.head = ListNode(val)
            <span class="keyword">return</span>
        curr = self.head
        <span class="keyword">while</span> curr.next:
            curr = curr.next
        curr.next = ListNode(val)

    <span class="keyword">def</span> <span class="function">prepend</span>(self, val):
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node

    <span class="keyword">def</span> <span class="function">delete</span>(self, val):
        <span class="keyword">if not</span> self.head:
            <span class="keyword">return</span>
        <span class="keyword">if</span> self.head.val == val:
            self.head = self.head.next
            <span class="keyword">return</span>
        curr = self.head
        <span class="keyword">while</span> curr.next <span class="keyword">and</span> curr.next.val != val:
            curr = curr.next
        <span class="keyword">if</span> curr.next:
            curr.next = curr.next.next

    <span class="keyword">def</span> <span class="function">reverse</span>(self):
        prev = <span class="keyword">None</span>
        curr = self.head
        <span class="keyword">while</span> curr:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp
        self.head = prev</code>
                    <code class="code-content" id="ll-java"><span class="comment">// Singly Linked List Implementation</span>

<span class="keyword">class</span> <span class="class-name">ListNode</span> {
    <span class="keyword">int</span> val;
    ListNode next;
    ListNode(<span class="keyword">int</span> val) { <span class="keyword">this</span>.val = val; }
}

<span class="keyword">class</span> <span class="class-name">LinkedList</span> {
    ListNode head;

    <span class="keyword">void</span> <span class="function">append</span>(<span class="keyword">int</span> val) {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {
            head = <span class="keyword">new</span> ListNode(val);
            <span class="keyword">return</span>;
        }
        ListNode curr = head;
        <span class="keyword">while</span> (curr.next != <span class="keyword">null</span>) curr = curr.next;
        curr.next = <span class="keyword">new</span> ListNode(val);
    }

    <span class="keyword">void</span> <span class="function">prepend</span>(<span class="keyword">int</span> val) {
        ListNode newNode = <span class="keyword">new</span> ListNode(val);
        newNode.next = head;
        head = newNode;
    }

    ListNode <span class="function">reverse</span>(ListNode head) {
        ListNode prev = <span class="keyword">null</span>;
        ListNode curr = head;
        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        <span class="keyword">return</span> prev;
    }
}</code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="linked-list" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">206. Reverse Linked List</span><span class="pattern-tag">linked-list</span>
                            <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Reverse a singly linked list.</p>
                            <p><strong>Pattern:</strong> Three pointers - prev, curr, next</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Iterative:</strong> Need 3 pointers - prev, curr, next.</li>
                                    <li><strong>At Each Node:</strong> Save next, point curr to prev, move prev and curr forward.</li>
                                    <li><strong>Recursive:</strong> Reverse rest of list, then point next node back to current.</li>
                                    <li><strong>Return:</strong> prev (iterative) or new head from recursion.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">reverseList</span>(head):
    prev = <span class="keyword">None</span>
    curr = head

    <span class="keyword">while</span> curr:
        next_temp = curr.next  <span class="comment"># Save next</span>
        curr.next = prev       <span class="comment"># Reverse pointer</span>
        prev = curr            <span class="comment"># Move prev forward</span>
        curr = next_temp       <span class="comment"># Move curr forward</span>

    <span class="keyword">return</span> prev

<span class="comment"># Time: O(n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=G0_I-ZF0S38" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="linked-list" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">21. Merge Two Sorted Lists</span><span class="pattern-tag">linked-list</span>
                            <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Merge two sorted linked lists into one sorted list.</p>
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">mergeTwoLists</span>(l1, l2):
    dummy = ListNode(<span class="number">0</span>)
    curr = dummy

    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:
        <span class="keyword">if</span> l1.val <= l2.val:
            curr.next = l1
            l1 = l1.next
        <span class="keyword">else</span>:
            curr.next = l2
            l2 = l2.next
        curr = curr.next

    curr.next = l1 <span class="keyword">or</span> l2
    <span class="keyword">return</span> dummy.next

<span class="comment"># Time: O(n+m), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=XIdigk956u0" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="linked-list" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">141. Linked List Cycle</span><span class="pattern-tag">linked-list</span>
                            <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Detect if a linked list has a cycle.</p>
                            <p><strong>Pattern:</strong> Floyd's Tortoise and Hare (slow/fast pointers)</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Hash Set:</strong> Store visited nodes, check if seen again - O(n) space.</li>
                                    <li><strong>Floyd's Tortoise & Hare:</strong> Two pointers, one fast (2x), one slow.</li>
                                    <li><strong>Why It Works:</strong> If cycle exists, fast will eventually meet slow.</li>
                                    <li><strong>No Cycle:</strong> Fast pointer reaches null.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Dummy Node:</strong> Create dummy to simplify edge cases.</li>
                                    <li><strong>Compare & Link:</strong> Always pick smaller node, advance that pointer.</li>
                                    <li><strong>Remaining:</strong> When one list ends, link remaining of other.</li>
                                    <li><strong>Return:</strong> dummy.next (skip the dummy).</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">hasCycle</span>(head):
    slow = fast = head

    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
        slow = slow.next
        fast = fast.next.next

        <span class="keyword">if</span> slow == fast:
            <span class="keyword">return True</span>

    <span class="keyword">return False</span>

<span class="comment"># Time: O(n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=gBTe7lFR3vc" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="linked-list" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">19. Remove Nth Node From End</span><span class="pattern-tag">linked-list</span>
                            <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Remove the nth node from the end in one pass.</p>
                            <p><strong>Pattern:</strong> Two pointers with n gap</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Two Pass:</strong> Count length, then remove (length - n + 1)th node.</li>
                                    <li><strong>One Pass:</strong> Use two pointers with n nodes gap.</li>
                                    <li><strong>Setup:</strong> Move fast pointer n steps ahead first.</li>
                                    <li><strong>Then:</strong> Move both until fast reaches end. Slow is at target.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">removeNthFromEnd</span>(head, n):
    dummy = ListNode(<span class="number">0</span>, head)
    slow = fast = dummy

    <span class="comment"># Move fast n+1 steps ahead</span>
    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(n + <span class="number">1</span>):
        fast = fast.next

    <span class="comment"># Move both until fast reaches end</span>
    <span class="keyword">while</span> fast:
        slow = slow.next
        fast = fast.next

    <span class="comment"># Remove nth node</span>
    slow.next = slow.next.next

    <span class="keyword">return</span> dummy.next

<span class="comment"># Time: O(n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=XVuQxVej6y8" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="linked-list" data-difficulty="hard"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">23. Merge k Sorted Lists</span><span class="pattern-tag">linked-list</span>
                            <a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Merge k sorted linked lists into one sorted list.</p>
                            <p><strong>Pattern:</strong> Divide and conquer or min-heap</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Brute Force:</strong> Merge lists one by one - O(kN).</li>
                                    <li><strong>Min Heap:</strong> Always pick smallest from k lists - O(N log k).</li>
                                    <li><strong>Divide & Conquer:</strong> Merge pairs, reduce to k/2 lists each round.</li>
                                    <li><strong>Heap Approach:</strong> Push first node of each list, pop min, push its next.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">import</span> heapq

<span class="keyword">def</span> <span class="function">mergeKLists</span>(lists):
    <span class="comment"># Min-heap approach</span>
    heap = []

    <span class="comment"># Add first node of each list to heap</span>
    <span class="keyword">for</span> i, lst <span class="keyword">in</span> <span class="keyword">enumerate</span>(lists):
        <span class="keyword">if</span> lst:
            heapq.heappush(heap, (lst.val, i, lst))

    dummy = ListNode(<span class="number">0</span>)
    curr = dummy

    <span class="keyword">while</span> heap:
        val, i, node = heapq.heappop(heap)
        curr.next = node
        curr = curr.next

        <span class="keyword">if</span> node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))

    <span class="keyword">return</span> dummy.next

<span class="comment"># Time: O(n log k), Space: O(k)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=q5a5OiGbT6Q" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Stacks Section -->
        <section class="section" id="stacks">
            <div class="section-header">
                <h2>üìö Stacks</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-stacks" onchange="updateProgress()">
                    <label for="check-stacks">Mark as completed</label>
                </div>

                <h3>What is a Stack?</h3>
                <p>A stack is a Last-In-First-Out (LIFO) data structure. Elements are added and removed from the same end (top). Think of a stack of plates - you can only add or remove from the top.</p>

                <div class="complexity">
                    <span class="time">Push: O(1)</span>
                    <span class="time">Pop: O(1)</span>
                    <span class="time">Peek: O(1)</span>
                    <span class="space">Space: O(n)</span>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Function call stack:</strong> Managing function calls and returns</li>
                        <li><strong>Undo/Redo:</strong> Text editors, image editors</li>
                        <li><strong>Browser back button:</strong> Navigation history</li>
                        <li><strong>Expression evaluation:</strong> Calculators, compilers</li>
                        <li><strong>Syntax parsing:</strong> Matching brackets, HTML tags</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=F1F2imiOJfk" target="_blank" class="link-btn">üì∫ Stacks - HackerRank</a>
                    <a href="https://www.youtube.com/watch?v=L3ud3rXpIxA" target="_blank" class="link-btn">üì∫ Stack Data Structure - CS Dojo</a>
                </div>

                <h3>üíª Implementation</h3>
                <div class="code-block">
                    <code class="code-content active"><span class="comment"># Stack using Python list</span>
stack = []

<span class="comment"># Push - O(1)</span>
stack.append(<span class="number">1</span>)
stack.append(<span class="number">2</span>)
stack.append(<span class="number">3</span>)

<span class="comment"># Pop - O(1)</span>
top = stack.pop()  <span class="comment"># Returns 3</span>

<span class="comment"># Peek - O(1)</span>
top = stack[-<span class="number">1</span>]  <span class="comment"># Returns 2 without removing</span>

<span class="comment"># Check empty</span>
is_empty = <span class="keyword">len</span>(stack) == <span class="number">0</span>

<span class="comment"># Stack class implementation</span>
<span class="keyword">class</span> <span class="class-name">Stack</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.items = []

    <span class="keyword">def</span> <span class="function">push</span>(self, item):
        self.items.append(item)

    <span class="keyword">def</span> <span class="function">pop</span>(self):
        <span class="keyword">if not</span> self.is_empty():
            <span class="keyword">return</span> self.items.pop()

    <span class="keyword">def</span> <span class="function">peek</span>(self):
        <span class="keyword">if not</span> self.is_empty():
            <span class="keyword">return</span> self.items[-<span class="number">1</span>]

    <span class="keyword">def</span> <span class="function">is_empty</span>(self):
        <span class="keyword">return len</span>(self.items) == <span class="number">0</span></code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="stack" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">20. Valid Parentheses</span><span class="pattern-tag">stack</span>
                            <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Check if brackets are properly matched and nested.</p>
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">isValid</span>(s):
    stack = []
    mapping = {<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">'}'</span>: <span class="string">'{'</span>, <span class="string">']'</span>: <span class="string">'['</span>}

    <span class="keyword">for</span> char <span class="keyword">in</span> s:
        <span class="keyword">if</span> char <span class="keyword">in</span> mapping:
            <span class="keyword">if not</span> stack <span class="keyword">or</span> stack.pop() != mapping[char]:
                <span class="keyword">return False</span>
        <span class="keyword">else</span>:
            stack.append(char)

    <span class="keyword">return len</span>(stack) == <span class="number">0</span>

<span class="comment"># Time: O(n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=WTzjTskDFMg" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="stack" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">155. Min Stack</span><span class="pattern-tag">stack</span>
                            <a href="https://leetcode.com/problems/min-stack/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Design a stack that supports getMin() in O(1).</p>
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">class</span> <span class="class-name">MinStack</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.stack = []
        self.min_stack = []

    <span class="keyword">def</span> <span class="function">push</span>(self, val):
        self.stack.append(val)
        <span class="comment"># Track minimum at each level</span>
        min_val = <span class="keyword">min</span>(val, self.min_stack[-<span class="number">1</span>] <span class="keyword">if</span> self.min_stack <span class="keyword">else</span> val)
        self.min_stack.append(min_val)

    <span class="keyword">def</span> <span class="function">pop</span>(self):
        self.stack.pop()
        self.min_stack.pop()

    <span class="keyword">def</span> <span class="function">top</span>(self):
        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]

    <span class="keyword">def</span> <span class="function">getMin</span>(self):
        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]

<span class="comment"># All operations O(1) time</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=qkLl7nAwDPo" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="stack" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">739. Daily Temperatures</span><span class="pattern-tag">stack</span>
                            <a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find days until warmer temperature.</p>
                            <p><strong>Pattern:</strong> Monotonic decreasing stack</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Brute Force:</strong> For each day, scan right for warmer - O(n¬≤).</li>
                                    <li><strong>Monotonic Stack:</strong> Stack of indices with decreasing temps.</li>
                                    <li><strong>On Warmer Day:</strong> Pop all cooler days, calculate their wait time.</li>
                                    <li><strong>Key:</strong> Each index pushed and popped once - O(n).</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Challenge:</strong> getMin() in O(1) even after pops.</li>
                                    <li><strong>Key Insight:</strong> Track minimum at each stack state.</li>
                                    <li><strong>Two Stacks:</strong> Main stack + min stack (or store tuples).</li>
                                    <li><strong>On Push:</strong> Push current min alongside value.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Stack Pattern:</strong> Opening brackets push, closing brackets pop.</li>
                                    <li><strong>Matching:</strong> Closing must match most recent opening.</li>
                                    <li><strong>Invalid Cases:</strong> Pop from empty stack, or mismatch, or stack not empty at end.</li>
                                    <li><strong>Use Map:</strong> Map closing to opening for easy matching.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">dailyTemperatures</span>(temperatures):
    n = <span class="keyword">len</span>(temperatures)
    result = [<span class="number">0</span>] * n
    stack = []  <span class="comment"># Stack of indices</span>

    <span class="keyword">for</span> i, temp <span class="keyword">in</span> <span class="keyword">enumerate</span>(temperatures):
        <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[stack[-<span class="number">1</span>]] < temp:
            prev_idx = stack.pop()
            result[prev_idx] = i - prev_idx
        stack.append(i)

    <span class="keyword">return</span> result

<span class="comment"># Time: O(n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=cTBiBSnjO3c" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="stack" data-difficulty="hard"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">84. Largest Rectangle in Histogram</span><span class="pattern-tag">stack</span>
                            <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find the largest rectangular area in a histogram.</p>
                            <p><strong>Pattern:</strong> Monotonic stack to find boundaries</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>For Each Bar:</strong> Find how far left and right it can extend.</li>
                                    <li><strong>Monotonic Stack:</strong> Stack of indices with increasing heights.</li>
                                    <li><strong>On Smaller Bar:</strong> Pop and calculate area with popped as height.</li>
                                    <li><strong>Width:</strong> Current index - stack top - 1 (or current index if stack empty).</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">largestRectangleArea</span>(heights):
    stack = []  <span class="comment"># Stack of indices</span>
    max_area = <span class="number">0</span>

    <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="keyword">enumerate</span>(heights + [<span class="number">0</span>]):
        <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] > h:
            height = heights[stack.pop()]
            width = i <span class="keyword">if not</span> stack <span class="keyword">else</span> i - stack[-<span class="number">1</span>] - <span class="number">1</span>
            max_area = <span class="keyword">max</span>(max_area, height * width)
        stack.append(i)

    <span class="keyword">return</span> max_area

<span class="comment"># Time: O(n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=zx5Sw9130L0" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Queues Section -->
        <section class="section" id="queues">
            <div class="section-header">
                <h2>üö∂ Queues</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-queues" onchange="updateProgress()">
                    <label for="check-queues">Mark as completed</label>
                </div>

                <h3>What is a Queue?</h3>
                <p>A queue is a First-In-First-Out (FIFO) data structure. Elements are added at the rear and removed from the front. Think of a line at a store - first person in line is served first.</p>

                <div class="complexity">
                    <span class="time">Enqueue: O(1)</span>
                    <span class="time">Dequeue: O(1)</span>
                    <span class="time">Peek: O(1)</span>
                    <span class="space">Space: O(n)</span>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Task scheduling:</strong> CPU process scheduling, print queues</li>
                        <li><strong>BFS traversal:</strong> Graph and tree level-order traversal</li>
                        <li><strong>Message queues:</strong> Kafka, RabbitMQ, SQS</li>
                        <li><strong>Request handling:</strong> Web servers processing requests</li>
                        <li><strong>Buffering:</strong> Streaming data, IO operations</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=wjI1WNcIntg" target="_blank" class="link-btn">üì∫ Queues - HackerRank</a>
                </div>

                <h3>üíª Implementation</h3>
                <div class="code-block">
                    <code class="code-content active"><span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="comment"># Using deque for efficient O(1) operations</span>
queue = deque()

<span class="comment"># Enqueue - O(1)</span>
queue.append(<span class="number">1</span>)
queue.append(<span class="number">2</span>)
queue.append(<span class="number">3</span>)

<span class="comment"># Dequeue - O(1)</span>
front = queue.popleft()  <span class="comment"># Returns 1</span>

<span class="comment"># Peek front - O(1)</span>
front = queue[<span class="number">0</span>]  <span class="comment"># Returns 2</span>

<span class="comment"># Check empty</span>
is_empty = <span class="keyword">len</span>(queue) == <span class="number">0</span>

<span class="comment"># Queue class implementation</span>
<span class="keyword">class</span> <span class="class-name">Queue</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.items = deque()

    <span class="keyword">def</span> <span class="function">enqueue</span>(self, item):
        self.items.append(item)

    <span class="keyword">def</span> <span class="function">dequeue</span>(self):
        <span class="keyword">if not</span> self.is_empty():
            <span class="keyword">return</span> self.items.popleft()

    <span class="keyword">def</span> <span class="function">peek</span>(self):
        <span class="keyword">if not</span> self.is_empty():
            <span class="keyword">return</span> self.items[<span class="number">0</span>]

    <span class="keyword">def</span> <span class="function">is_empty</span>(self):
        <span class="keyword">return len</span>(self.items) == <span class="number">0</span></code>
                </div>
            </div>
        </section>

        <!-- Hash Tables Section -->
        <section class="section" id="hashtables">
            <div class="section-header">
                <h2>#Ô∏è‚É£ Hash Tables</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-hashtables" onchange="updateProgress()">
                    <label for="check-hashtables">Mark as completed</label>
                </div>

                <h3>What is a Hash Table?</h3>
                <p>A hash table (hash map) stores key-value pairs and provides O(1) average time complexity for insertion, deletion, and lookup. It uses a hash function to compute an index where the value is stored.</p>

                <div class="complexity">
                    <span class="time">Insert: O(1) avg</span>
                    <span class="time">Delete: O(1) avg</span>
                    <span class="time">Search: O(1) avg</span>
                    <span class="space">Space: O(n)</span>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Database indexing:</strong> Quick record lookup by key</li>
                        <li><strong>Caching:</strong> Redis, Memcached</li>
                        <li><strong>Symbol tables:</strong> Compilers and interpreters</li>
                        <li><strong>Counting/Frequency:</strong> Word count, analytics</li>
                        <li><strong>Deduplication:</strong> Removing duplicate entries</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=shs0KM3wKv8" target="_blank" class="link-btn">üì∫ Hash Tables - CS50</a>
                    <a href="https://www.youtube.com/watch?v=sfWyugl4JWA" target="_blank" class="link-btn">üì∫ Hash Tables - HackerRank</a>
                </div>

                <h3>üíª Common Patterns</h3>
                <div class="code-block">
                    <code class="code-content active"><span class="comment"># Python dict operations</span>

<span class="comment"># Create hash map</span>
hash_map = {}
hash_map = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>}

<span class="comment"># Insert/Update - O(1)</span>
hash_map[<span class="string">'c'</span>] = <span class="number">3</span>

<span class="comment"># Get with default - O(1)</span>
val = hash_map.get(<span class="string">'d'</span>, <span class="number">0</span>)  <span class="comment"># Returns 0 if not found</span>

<span class="comment"># Delete - O(1)</span>
<span class="keyword">del</span> hash_map[<span class="string">'a'</span>]

<span class="comment"># Check existence - O(1)</span>
<span class="keyword">if</span> <span class="string">'b'</span> <span class="keyword">in</span> hash_map:
    <span class="keyword">print</span>(<span class="string">"Found"</span>)

<span class="comment"># Iterate</span>
<span class="keyword">for</span> key, value <span class="keyword">in</span> hash_map.items():
    <span class="keyword">print</span>(key, value)

<span class="comment"># Counter for frequency</span>
<span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict

text = <span class="string">"hello"</span>
freq = Counter(text)  <span class="comment"># {'l': 2, 'h': 1, 'e': 1, 'o': 1}</span>

<span class="comment"># defaultdict for grouping</span>
groups = defaultdict(<span class="keyword">list</span>)
groups[<span class="string">'key'</span>].append(<span class="number">1</span>)  <span class="comment"># No KeyError if key doesn't exist</span></code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="heap" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">347. Top K Frequent Elements</span><span class="pattern-tag">heap</span>
                            <a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Return the k most frequent elements.</p>
                            <p><strong>Pattern:</strong> Hash map + bucket sort or heap</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Step 1:</strong> Count frequencies using hash map.</li>
                                    <li><strong>Heap Approach:</strong> Use min-heap of size k - O(n log k).</li>
                                    <li><strong>Bucket Sort:</strong> Index = frequency, value = elements - O(n).</li>
                                    <li><strong>Python Trick:</strong> Counter.most_common(k) does it all!</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">topKFrequent</span>(nums, k):
    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter

    <span class="comment"># Count frequencies</span>
    count = Counter(nums)

    <span class="comment"># Bucket sort approach - O(n)</span>
    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">len</span>(nums) + <span class="number">1</span>)]

    <span class="keyword">for</span> num, freq <span class="keyword">in</span> count.items():
        buckets[freq].append(num)

    result = []
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">len</span>(buckets) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):
        <span class="keyword">for</span> num <span class="keyword">in</span> buckets[i]:
            result.append(num)
            <span class="keyword">if len</span>(result) == k:
                <span class="keyword">return</span> result

    <span class="keyword">return</span> result

<span class="comment"># Time: O(n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=YPTqKIgVk-k" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="hash-map" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">146. LRU Cache</span><span class="pattern-tag">hash-map</span>
                            <a href="https://leetcode.com/problems/lru-cache/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Design a Least Recently Used cache.</p>
                            <p><strong>Pattern:</strong> Hash map + Doubly linked list</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Requirements:</strong> O(1) get and put, evict least recently used.</li>
                                    <li><strong>Hash Map:</strong> For O(1) key lookup.</li>
                                    <li><strong>Doubly Linked List:</strong> For O(1) removal and insertion at ends.</li>
                                    <li><strong>Combine:</strong> Map stores key ‚Üí node, list maintains usage order.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">class</span> <span class="class-name">LRUCache</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, capacity):
        self.capacity = capacity
        self.cache = {}  <span class="comment"># key -> node</span>
        <span class="comment"># Doubly linked list with dummy head/tail</span>
        self.head = self.tail = <span class="keyword">None</span>
        self._init_list()

    <span class="keyword">def</span> <span class="function">get</span>(self, key):
        <span class="keyword">if</span> key <span class="keyword">not in</span> self.cache:
            <span class="keyword">return</span> -<span class="number">1</span>
        <span class="comment"># Move to front (most recently used)</span>
        self._move_to_front(self.cache[key])
        <span class="keyword">return</span> self.cache[key].val

    <span class="keyword">def</span> <span class="function">put</span>(self, key, value):
        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:
            self.cache[key].val = value
            self._move_to_front(self.cache[key])
        <span class="keyword">else</span>:
            <span class="keyword">if len</span>(self.cache) >= self.capacity:
                <span class="comment"># Remove LRU (from tail)</span>
                lru = self.tail.prev
                self._remove(lru)
                <span class="keyword">del</span> self.cache[lru.key]
            <span class="comment"># Add new node</span>
            node = Node(key, value)
            self.cache[key] = node
            self._add_to_front(node)

<span class="comment"># Time: O(1) for both get and put</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=7ABFKPK2hD4" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Binary Trees Section -->
        <section class="section" id="trees">
            <div class="section-header">
                <h2>üå≥ Binary Trees</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-trees" onchange="updateProgress()">
                    <label for="check-trees">Mark as completed</label>
                </div>

                <h3>What is a Binary Tree?</h3>
                <p>A binary tree is a hierarchical data structure where each node has at most two children (left and right). Trees are used to represent hierarchical relationships and enable efficient operations.</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>Tree Traversals</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li><strong>Inorder (LNR):</strong> Left, Node, Right</li>
                            <li><strong>Preorder (NLR):</strong> Node, Left, Right</li>
                            <li><strong>Postorder (LRN):</strong> Left, Right, Node</li>
                            <li><strong>Level Order:</strong> BFS by levels</li>
                        </ul>
                    </div>
                    <div class="topic-card">
                        <h4>Tree Properties</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li><strong>Height:</strong> Longest path to leaf</li>
                            <li><strong>Depth:</strong> Distance from root</li>
                            <li><strong>Balanced:</strong> Height diff ‚â§ 1</li>
                            <li><strong>Complete:</strong> All levels filled</li>
                        </ul>
                    </div>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>File systems:</strong> Directory structure</li>
                        <li><strong>DOM:</strong> HTML document structure</li>
                        <li><strong>Databases:</strong> B-trees for indexing</li>
                        <li><strong>Compilers:</strong> Abstract syntax trees</li>
                        <li><strong>AI/ML:</strong> Decision trees</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=fAAZixBzIAI" target="_blank" class="link-btn">üì∫ Binary Trees - HackerRank</a>
                    <a href="https://www.youtube.com/watch?v=BHB0B1jFKQc" target="_blank" class="link-btn">üì∫ Tree Traversals - Abdul Bari</a>
                </div>

                <h3>üíª Implementation</h3>
                <div class="code-block">
                    <code class="code-content active"><span class="comment"># Binary Tree Node</span>
<span class="keyword">class</span> <span class="class-name">TreeNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, val=<span class="number">0</span>, left=<span class="keyword">None</span>, right=<span class="keyword">None</span>):
        self.val = val
        self.left = left
        self.right = right

<span class="comment"># Inorder Traversal (Recursive)</span>
<span class="keyword">def</span> <span class="function">inorder</span>(root):
    <span class="keyword">if not</span> root:
        <span class="keyword">return</span> []
    <span class="keyword">return</span> inorder(root.left) + [root.val] + inorder(root.right)

<span class="comment"># Inorder Traversal (Iterative)</span>
<span class="keyword">def</span> <span class="function">inorderIterative</span>(root):
    result, stack = [], []
    curr = root
    <span class="keyword">while</span> curr <span class="keyword">or</span> stack:
        <span class="keyword">while</span> curr:
            stack.append(curr)
            curr = curr.left
        curr = stack.pop()
        result.append(curr.val)
        curr = curr.right
    <span class="keyword">return</span> result

<span class="comment"># Level Order (BFS)</span>
<span class="keyword">def</span> <span class="function">levelOrder</span>(root):
    <span class="keyword">if not</span> root:
        <span class="keyword">return</span> []
    result = []
    queue = [root]
    <span class="keyword">while</span> queue:
        level = []
        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">len</span>(queue)):
            node = queue.pop(<span class="number">0</span>)
            level.append(node.val)
            <span class="keyword">if</span> node.left: queue.append(node.left)
            <span class="keyword">if</span> node.right: queue.append(node.right)
        result.append(level)
    <span class="keyword">return</span> result</code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="tree" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">104. Maximum Depth of Binary Tree</span><span class="pattern-tag">tree</span>
                            <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">maxDepth</span>(root):
    <span class="keyword">if not</span> root:
        <span class="keyword">return</span> <span class="number">0</span>
    <span class="keyword">return</span> <span class="number">1</span> + <span class="keyword">max</span>(maxDepth(root.left), maxDepth(root.right))

<span class="comment"># Time: O(n), Space: O(h) where h is height</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=hTM3phVI6YQ" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="tree" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">226. Invert Binary Tree</span><span class="pattern-tag">tree</span>
                            <a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">invertTree</span>(root):
    <span class="keyword">if not</span> root:
        <span class="keyword">return None</span>

    <span class="comment"># Swap children</span>
    root.left, root.right = root.right, root.left

    <span class="comment"># Recursively invert subtrees</span>
    invertTree(root.left)
    invertTree(root.right)

    <span class="keyword">return</span> root

<span class="comment"># Time: O(n), Space: O(h)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=OnSn2XEQ4MY" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="tree" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">100. Same Tree</span><span class="pattern-tag">tree</span>
                            <a href="https://leetcode.com/problems/same-tree/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">isSameTree</span>(p, q):
    <span class="keyword">if not</span> p <span class="keyword">and not</span> q:
        <span class="keyword">return True</span>
    <span class="keyword">if not</span> p <span class="keyword">or not</span> q <span class="keyword">or</span> p.val != q.val:
        <span class="keyword">return False</span>
    <span class="keyword">return</span> isSameTree(p.left, q.left) <span class="keyword">and</span> isSameTree(p.right, q.right)

<span class="comment"># Time: O(n), Space: O(h)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=vRbbcKXCxOw" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="tree" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">102. Binary Tree Level Order Traversal</span><span class="pattern-tag">tree</span>
                            <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">def</span> <span class="function">levelOrder</span>(root):
    <span class="keyword">if not</span> root:
        <span class="keyword">return</span> []

    result = []
    queue = deque([root])

    <span class="keyword">while</span> queue:
        level = []
        level_size = <span class="keyword">len</span>(queue)

        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(level_size):
            node = queue.popleft()
            level.append(node.val)

            <span class="keyword">if</span> node.left:
                queue.append(node.left)
            <span class="keyword">if</span> node.right:
                queue.append(node.right)

        result.append(level)

    <span class="keyword">return</span> result

<span class="comment"># Time: O(n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=6ZnyEApgFYg" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="tree" data-difficulty="hard"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">124. Binary Tree Maximum Path Sum</span><span class="pattern-tag">tree</span>
                            <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">maxPathSum</span>(root):
    max_sum = [<span class="keyword">float</span>(<span class="string">'-inf'</span>)]

    <span class="keyword">def</span> <span class="function">dfs</span>(node):
        <span class="keyword">if not</span> node:
            <span class="keyword">return</span> <span class="number">0</span>

        <span class="comment"># Max gain from left/right (ignore negative)</span>
        left_gain = <span class="keyword">max</span>(dfs(node.left), <span class="number">0</span>)
        right_gain = <span class="keyword">max</span>(dfs(node.right), <span class="number">0</span>)

        <span class="comment"># Path through current node</span>
        current_path = node.val + left_gain + right_gain
        max_sum[<span class="number">0</span>] = <span class="keyword">max</span>(max_sum[<span class="number">0</span>], current_path)

        <span class="comment"># Return max gain if continuing path</span>
        <span class="keyword">return</span> node.val + <span class="keyword">max</span>(left_gain, right_gain)

    dfs(root)
    <span class="keyword">return</span> max_sum[<span class="number">0</span>]

<span class="comment"># Time: O(n), Space: O(h)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=Hr5cWUld4vU" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- BST Section -->
        <section class="section" id="bst">
            <div class="section-header">
                <h2>üå≤ Binary Search Trees (BST)</h2>
                <span class="badge badge-intermediate">Intermediate</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-bst" onchange="updateProgress()">
                    <label for="check-bst">Mark as completed</label>
                </div>

                <h3>What is a BST?</h3>
                <p>A Binary Search Tree maintains the property: for every node, all values in the left subtree are smaller, and all values in the right subtree are larger. This enables O(log n) search, insert, and delete operations on average.</p>

                <div class="complexity">
                    <span class="time">Search: O(log n) avg</span>
                    <span class="time">Insert: O(log n) avg</span>
                    <span class="time">Delete: O(log n) avg</span>
                    <span class="space">Space: O(n)</span>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Database indexes:</strong> Quick data retrieval</li>
                        <li><strong>Symbol tables:</strong> Compilers</li>
                        <li><strong>Priority queues:</strong> When sorted order needed</li>
                        <li><strong>Autocomplete:</strong> Prefix-based search</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=pYT9F8_LFTM" target="_blank" class="link-btn">üì∫ BST - HackerRank</a>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="tree" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">98. Validate Binary Search Tree</span><span class="pattern-tag">tree</span>
                            <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">isValidBST</span>(root):
    <span class="keyword">def</span> <span class="function">validate</span>(node, min_val, max_val):
        <span class="keyword">if not</span> node:
            <span class="keyword">return True</span>

        <span class="keyword">if not</span> (min_val < node.val < max_val):
            <span class="keyword">return False</span>

        <span class="keyword">return</span> (validate(node.left, min_val, node.val) <span class="keyword">and</span>
                validate(node.right, node.val, max_val))

    <span class="keyword">return</span> validate(root, <span class="keyword">float</span>(<span class="string">'-inf'</span>), <span class="keyword">float</span>(<span class="string">'inf'</span>))

<span class="comment"># Time: O(n), Space: O(h)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=s6ATEkipzow" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="tree" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">230. Kth Smallest Element in a BST</span><span class="pattern-tag">tree</span>
                            <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Pattern:</strong> Inorder traversal gives sorted order</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Path Options:</strong> Through root, or entirely in left/right subtree.</li>
                                    <li><strong>At Each Node:</strong> Max gain = node.val + max(left, right, 0).</li>
                                    <li><strong>Full Path:</strong> node.val + left gain + right gain (can't go up).</li>
                                    <li><strong>Global Max:</strong> Track maximum path sum seen during traversal.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>BST Property:</strong> Inorder traversal gives sorted order!</li>
                                    <li><strong>Approach:</strong> Do inorder, stop at kth element.</li>
                                    <li><strong>Iterative:</strong> Use stack for inorder, count until k.</li>
                                    <li><strong>Optimization:</strong> No need to traverse entire tree.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>BST Property:</strong> Left < Node < Right for ALL nodes, not just children.</li>
                                    <li><strong>Range Approach:</strong> Each node must be within (min, max) range.</li>
                                    <li><strong>Update Ranges:</strong> Go left ‚Üí update max. Go right ‚Üí update min.</li>
                                    <li><strong>Alternative:</strong> Inorder traversal should be strictly increasing.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>BFS Pattern:</strong> Process nodes level by level.</li>
                                    <li><strong>Queue:</strong> Use queue, process all nodes at current level.</li>
                                    <li><strong>Level Size:</strong> Capture queue size at start of each level.</li>
                                    <li><strong>Build Result:</strong> Append level list to result after processing.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Base Cases:</strong> Both null = same. One null = different.</li>
                                    <li><strong>Compare Values:</strong> If values differ, not same.</li>
                                    <li><strong>Recurse:</strong> Both left subtrees same AND both right subtrees same.</li>
                                    <li><strong>Iterative:</strong> Use queue/stack to compare level by level.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Base Case:</strong> Empty tree returns None.</li>
                                    <li><strong>Swap Children:</strong> root.left, root.right = root.right, root.left</li>
                                    <li><strong>Recurse:</strong> Invert left subtree, invert right subtree.</li>
                                    <li><strong>Order:</strong> Can swap before or after recursion (pre/post-order).</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Base Case:</strong> Empty tree has depth 0.</li>
                                    <li><strong>Recursive:</strong> Depth = 1 + max(left depth, right depth).</li>
                                    <li><strong>Iterative BFS:</strong> Level-order traversal, count levels.</li>
                                    <li><strong>Iterative DFS:</strong> Stack with (node, depth) pairs.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">kthSmallest</span>(root, k):
    stack = []
    curr = root
    count = <span class="number">0</span>

    <span class="keyword">while</span> curr <span class="keyword">or</span> stack:
        <span class="keyword">while</span> curr:
            stack.append(curr)
            curr = curr.left

        curr = stack.pop()
        count += <span class="number">1</span>

        <span class="keyword">if</span> count == k:
            <span class="keyword">return</span> curr.val

        curr = curr.right

    <span class="keyword">return</span> -<span class="number">1</span>

<span class="comment"># Time: O(H + k), Space: O(H)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=5LUXSvjmGCw" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">235. Lowest Common Ancestor of BST</span>
                            <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">lowestCommonAncestor</span>(root, p, q):
    curr = root

    <span class="keyword">while</span> curr:
        <span class="keyword">if</span> p.val < curr.val <span class="keyword">and</span> q.val < curr.val:
            curr = curr.left  <span class="comment"># Both in left subtree</span>
        <span class="keyword">elif</span> p.val > curr.val <span class="keyword">and</span> q.val > curr.val:
            curr = curr.right  <span class="comment"># Both in right subtree</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span> curr  <span class="comment"># Split point = LCA</span>

<span class="comment"># Time: O(h), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=gs2LMfuOR9k" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ADVANCED LEVEL -->
        <section class="section" id="advanced">
            <div class="section-header">
                <h2>üî• Advanced Level</h2>
                <span class="badge badge-advanced">8-10 Weeks</span>
            </div>
            <div class="section-body">
                <p>Master complex algorithms and data structures. This level covers graph algorithms, dynamic programming, and advanced problem-solving techniques essential for technical interviews at top companies.</p>
            </div>
        </section>

        <!-- Heaps Section -->
        <section class="section" id="heaps">
            <div class="section-header">
                <h2>‚õ∞Ô∏è Heaps / Priority Queues</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-heaps" onchange="updateProgress()">
                    <label for="check-heaps">Mark as completed</label>
                </div>

                <h3>What is a Heap?</h3>
                <p>A heap is a complete binary tree that satisfies the heap property. In a max-heap, parent nodes are always greater than children. In a min-heap, parent nodes are always smaller. Heaps are commonly implemented using arrays.</p>

                <div class="complexity">
                    <span class="time">Insert: O(log n)</span>
                    <span class="time">Extract Min/Max: O(log n)</span>
                    <span class="time">Peek: O(1)</span>
                    <span class="time">Heapify: O(n)</span>
                    <span class="space">Space: O(n)</span>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Priority scheduling:</strong> OS process scheduling, task queues</li>
                        <li><strong>Dijkstra's algorithm:</strong> Shortest path finding</li>
                        <li><strong>Event-driven simulation:</strong> Processing events by time</li>
                        <li><strong>K-way merge:</strong> External sorting, merge k sorted lists</li>
                        <li><strong>Median finding:</strong> Stream of numbers</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=t0Cq6tVNRBA" target="_blank" class="link-btn">üì∫ Heaps - HackerRank</a>
                    <a href="https://www.youtube.com/watch?v=HqPJF2L5h9U" target="_blank" class="link-btn">üì∫ Heap Sort - Abdul Bari</a>
                </div>

                <h3>üíª Implementation</h3>
                <div class="code-block">
                    <code class="code-content active"><span class="keyword">import</span> heapq

<span class="comment"># Python heapq is a MIN-HEAP</span>

<span class="comment"># Create heap</span>
heap = []

<span class="comment"># Push - O(log n)</span>
heapq.heappush(heap, <span class="number">3</span>)
heapq.heappush(heap, <span class="number">1</span>)
heapq.heappush(heap, <span class="number">2</span>)

<span class="comment"># Pop minimum - O(log n)</span>
min_val = heapq.heappop(heap)  <span class="comment"># Returns 1</span>

<span class="comment"># Peek minimum - O(1)</span>
min_val = heap[<span class="number">0</span>]

<span class="comment"># Heapify list - O(n)</span>
arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>]
heapq.heapify(arr)

<span class="comment"># MAX-HEAP trick: negate values</span>
max_heap = []
heapq.heappush(max_heap, -<span class="number">5</span>)
heapq.heappush(max_heap, -<span class="number">3</span>)
max_val = -heapq.heappop(max_heap)  <span class="comment"># Returns 5</span>

<span class="comment"># K largest elements</span>
k_largest = heapq.nlargest(<span class="number">3</span>, arr)

<span class="comment"># K smallest elements</span>
k_smallest = heapq.nsmallest(<span class="number">3</span>, arr)</code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="heap" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">215. Kth Largest Element in an Array</span><span class="pattern-tag">heap</span>
                            <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">import</span> heapq

<span class="keyword">def</span> <span class="function">findKthLargest</span>(nums, k):
    <span class="comment"># Min-heap of size k</span>
    heap = nums[:k]
    heapq.heapify(heap)

    <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:
        <span class="keyword">if</span> num > heap[<span class="number">0</span>]:
            heapq.heapreplace(heap, num)

    <span class="keyword">return</span> heap[<span class="number">0</span>]

<span class="comment"># Time: O(n log k), Space: O(k)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=XEmy13g1Qxc" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="heap" data-difficulty="hard"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">295. Find Median from Data Stream</span><span class="pattern-tag">heap</span>
                            <a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Pattern:</strong> Two heaps (max-heap for lower half, min-heap for upper half)</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>BST Property:</strong> Left < Root < Right helps navigation.</li>
                                    <li><strong>Both Smaller:</strong> LCA is in right subtree.</li>
                                    <li><strong>Both Larger:</strong> LCA is in left subtree.</li>
                                    <li><strong>Split Point:</strong> When p and q are on different sides, current node is LCA.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Sorting:</strong> Sort and return nums[n-k] - O(n log n).</li>
                                    <li><strong>Min Heap:</strong> Keep heap of size k - O(n log k).</li>
                                    <li><strong>QuickSelect:</strong> Partition like quicksort - O(n) average.</li>
                                    <li><strong>Key:</strong> Kth largest = (n-k)th smallest (0-indexed).</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">import</span> heapq

<span class="keyword">class</span> <span class="class-name">MedianFinder</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.small = []  <span class="comment"># Max-heap (negated)</span>
        self.large = []  <span class="comment"># Min-heap</span>

    <span class="keyword">def</span> <span class="function">addNum</span>(self, num):
        heapq.heappush(self.small, -num)

        <span class="comment"># Ensure small's max <= large's min</span>
        <span class="keyword">if</span> self.small <span class="keyword">and</span> self.large <span class="keyword">and</span> \
           (-self.small[<span class="number">0</span>]) > self.large[<span class="number">0</span>]:
            heapq.heappush(self.large, -heapq.heappop(self.small))

        <span class="comment"># Balance sizes</span>
        <span class="keyword">if len</span>(self.small) > <span class="keyword">len</span>(self.large) + <span class="number">1</span>:
            heapq.heappush(self.large, -heapq.heappop(self.small))
        <span class="keyword">if len</span>(self.large) > <span class="keyword">len</span>(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    <span class="keyword">def</span> <span class="function">findMedian</span>(self):
        <span class="keyword">if len</span>(self.small) > <span class="keyword">len</span>(self.large):
            <span class="keyword">return</span> -self.small[<span class="number">0</span>]
        <span class="keyword">return</span> (-self.small[<span class="number">0</span>] + self.large[<span class="number">0</span>]) / <span class="number">2</span>

<span class="comment"># addNum: O(log n), findMedian: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=itmhHWaHupI" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="graph" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">133. Clone Graph</span><span class="pattern-tag">graph</span>
                            <a href="https://leetcode.com/problems/clone-graph/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Pattern:</strong> DFS/BFS with hash map for cloned nodes</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Challenge:</strong> Nodes have references to each other (cycles possible).</li>
                                    <li><strong>Hash Map:</strong> Map original node ‚Üí cloned node.</li>
                                    <li><strong>DFS/BFS:</strong> Visit each node, create clone, connect neighbors.</li>
                                    <li><strong>Check Map:</strong> If already cloned, return existing clone (handles cycles).</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">cloneGraph</span>(node):
    <span class="keyword">if not</span> node:
        <span class="keyword">return None</span>

    cloned = {}  <span class="comment"># original -> clone mapping</span>

    <span class="keyword">def</span> <span class="function">dfs</span>(node):
        <span class="keyword">if</span> node <span class="keyword">in</span> cloned:
            <span class="keyword">return</span> cloned[node]

        clone = Node(node.val)
        cloned[node] = clone

        <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:
            clone.neighbors.append(dfs(neighbor))

        <span class="keyword">return</span> clone

    <span class="keyword">return</span> dfs(node)

<span class="comment"># Time: O(V+E), Space: O(V)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=mQeF6bN8hMk" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">207. Course Schedule (Cycle Detection)</span>
                            <a href="https://leetcode.com/problems/course-schedule/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Pattern:</strong> Detect cycle in directed graph using DFS</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Model as Graph:</strong> Courses = nodes, prerequisites = directed edges.</li>
                                    <li><strong>Cycle = Impossible:</strong> If cycle exists, can't complete all courses.</li>
                                    <li><strong>DFS with States:</strong> Unvisited, Visiting (in path), Visited (done).</li>
                                    <li><strong>Cycle Found:</strong> If we reach a "Visiting" node, there's a cycle.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">canFinish</span>(numCourses, prerequisites):
    graph = {i: [] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(numCourses)}
    <span class="keyword">for</span> course, prereq <span class="keyword">in</span> prerequisites:
        graph[course].append(prereq)

    <span class="comment"># 0: unvisited, 1: visiting, 2: visited</span>
    state = [<span class="number">0</span>] * numCourses

    <span class="keyword">def</span> <span class="function">hasCycle</span>(course):
        <span class="keyword">if</span> state[course] == <span class="number">1</span>:  <span class="comment"># Cycle detected</span>
            <span class="keyword">return True</span>
        <span class="keyword">if</span> state[course] == <span class="number">2</span>:  <span class="comment"># Already processed</span>
            <span class="keyword">return False</span>

        state[course] = <span class="number">1</span>  <span class="comment"># Mark visiting</span>

        <span class="keyword">for</span> prereq <span class="keyword">in</span> graph[course]:
            <span class="keyword">if</span> hasCycle(prereq):
                <span class="keyword">return True</span>

        state[course] = <span class="number">2</span>  <span class="comment"># Mark visited</span>
        <span class="keyword">return False</span>

    <span class="keyword">for</span> course <span class="keyword">in</span> <span class="keyword">range</span>(numCourses):
        <span class="keyword">if</span> hasCycle(course):
            <span class="keyword">return False</span>

    <span class="keyword">return True</span>

<span class="comment"># Time: O(V+E), Space: O(V+E)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=EgI5nU9etnU" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Dynamic Programming Section -->
        <section class="section" id="dp">
            <div class="section-header">
                <h2>üí° Dynamic Programming</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-dp" onchange="updateProgress()">
                    <label for="check-dp">Mark as completed</label>
                </div>

                <h3>What is Dynamic Programming?</h3>
                <p>Dynamic Programming is an optimization technique that solves complex problems by breaking them into simpler subproblems. It stores results of subproblems to avoid redundant computation (memoization) or builds solutions bottom-up (tabulation).</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>When to Use DP?</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>Optimal substructure</li>
                            <li>Overlapping subproblems</li>
                            <li>Counting problems</li>
                            <li>Optimization (min/max)</li>
                        </ul>
                    </div>
                    <div class="topic-card">
                        <h4>Common Patterns</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>1D DP (Fibonacci, Climbing Stairs)</li>
                            <li>2D DP (Grid paths, LCS)</li>
                            <li>Knapsack variants</li>
                            <li>Interval DP</li>
                        </ul>
                    </div>
                </div>

                <div class="applications">
                    <h5>üåç Real-World Applications</h5>
                    <ul>
                        <li><strong>Resource allocation:</strong> Budget optimization</li>
                        <li><strong>Text comparison:</strong> Diff tools, spell check</li>
                        <li><strong>Bioinformatics:</strong> DNA sequence alignment</li>
                        <li><strong>Finance:</strong> Portfolio optimization</li>
                        <li><strong>Routing:</strong> Network packet routing</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=oBt53YbR9Kk" target="_blank" class="link-btn">üì∫ DP Tutorial - freeCodeCamp</a>
                    <a href="https://www.youtube.com/watch?v=nqowUJzG-iM" target="_blank" class="link-btn">üì∫ DP Introduction - Abdul Bari</a>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="dp" data-difficulty="easy"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">70. Climbing Stairs</span><span class="pattern-tag">dp</span>
                            <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Count ways to climb n stairs taking 1 or 2 steps.</p>
                            <p><strong>Pattern:</strong> Fibonacci sequence</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Choices:</strong> At each step, take 1 or 2 stairs.</li>
                                    <li><strong>Recurrence:</strong> ways(n) = ways(n-1) + ways(n-2)</li>
                                    <li><strong>It's Fibonacci!</strong> Base: ways(1)=1, ways(2)=2.</li>
                                    <li><strong>Optimize:</strong> Only need last 2 values, not full array.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">climbStairs</span>(n):
    <span class="keyword">if</span> n <= <span class="number">2</span>:
        <span class="keyword">return</span> n

    prev, curr = <span class="number">1</span>, <span class="number">2</span>
    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):
        prev, curr = curr, prev + curr

    <span class="keyword">return</span> curr

<span class="comment"># Time: O(n), Space: O(1)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=Y0lT9Fck7qI" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="dp" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">322. Coin Change</span><span class="pattern-tag">dp</span>
                            <a href="https://leetcode.com/problems/coin-change/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find minimum coins needed to make amount.</p>
                            <p><strong>Pattern:</strong> Unbounded knapsack</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Greedy Fails:</strong> Largest coins first doesn't always work.</li>
                                    <li><strong>DP State:</strong> dp[amount] = min coins needed for that amount.</li>
                                    <li><strong>Transition:</strong> dp[i] = min(dp[i], dp[i-coin] + 1) for each coin.</li>
                                    <li><strong>Build Up:</strong> Solve for 0, 1, 2... up to target amount.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">coinChange</span>(coins, amount):
    dp = [<span class="keyword">float</span>(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)
    dp[<span class="number">0</span>] = <span class="number">0</span>

    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:
        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">range</span>(coin, amount + <span class="number">1</span>):
            dp[x] = <span class="keyword">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)

    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="keyword">float</span>(<span class="string">'inf'</span>) <span class="keyword">else</span> -<span class="number">1</span>

<span class="comment"># Time: O(amount * n), Space: O(amount)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=H9bfqozjoqs" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="dp" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">300. Longest Increasing Subsequence</span><span class="pattern-tag">dp</span>
                            <a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find length of longest strictly increasing subsequence.</p>
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">lengthOfLIS</span>(nums):
    <span class="keyword">if not</span> nums:
        <span class="keyword">return</span> <span class="number">0</span>

    dp = [<span class="number">1</span>] * <span class="keyword">len</span>(nums)

    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, <span class="keyword">len</span>(nums)):
        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(i):
            <span class="keyword">if</span> nums[i] > nums[j]:
                dp[i] = <span class="keyword">max</span>(dp[i], dp[j] + <span class="number">1</span>)

    <span class="keyword">return max</span>(dp)

<span class="comment"># Time: O(n¬≤), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=cjWnW0hdF1Y" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="dp" data-difficulty="hard"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">72. Edit Distance</span><span class="pattern-tag">dp</span>
                            <a href="https://leetcode.com/problems/edit-distance/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find minimum operations to convert word1 to word2.</p>
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">minDistance</span>(word1, word2):
    m, n = <span class="keyword">len</span>(word1), <span class="keyword">len</span>(word2)
    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(m + <span class="number">1</span>)]

    <span class="comment"># Base cases</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(m + <span class="number">1</span>):
        dp[i][<span class="number">0</span>] = i
    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(n + <span class="number">1</span>):
        dp[<span class="number">0</span>][j] = j

    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):
        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):
            <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:
                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]
            <span class="keyword">else</span>:
                dp[i][j] = <span class="number">1</span> + <span class="keyword">min</span>(
                    dp[i-<span class="number">1</span>][j],    <span class="comment"># Delete</span>
                    dp[i][j-<span class="number">1</span>],    <span class="comment"># Insert</span>
                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>]  <span class="comment"># Replace</span>
                )

    <span class="keyword">return</span> dp[m][n]

<span class="comment"># Time: O(m*n), Space: O(m*n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=XYi2-LPrwm4" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Graphs Section -->
        <section class="section" id="graphs">
            <div class="section-header">
                <h2>üï∏Ô∏è Graphs</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-graphs" onchange="updateProgress()">
                    <label for="check-graphs">Mark as completed</label>
                </div>

                <h3>What are Graphs?</h3>
                <p>A graph is a collection of nodes (vertices) connected by edges. Graphs can be directed or undirected, weighted or unweighted. They're used to model relationships and networks.</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>Graph Representations</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li><strong>Adjacency List:</strong> Space O(V+E)</li>
                            <li><strong>Adjacency Matrix:</strong> Space O(V¬≤)</li>
                            <li><strong>Edge List:</strong> List of edges</li>
                        </ul>
                    </div>
                    <div class="topic-card">
                        <h4>Graph Traversals</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li><strong>BFS:</strong> Level by level, shortest path</li>
                            <li><strong>DFS:</strong> Deep exploration, backtracking</li>
                            <li><strong>Topological Sort:</strong> DAG ordering</li>
                        </ul>
                    </div>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=tWVWeAqZ0WU" target="_blank" class="link-btn">üì∫ Graph Algorithms - freeCodeCamp</a>
                    <a href="https://www.youtube.com/watch?v=pcKY4hjDrxk" target="_blank" class="link-btn">üì∫ BFS & DFS - Abdul Bari</a>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="graph" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">200. Number of Islands</span><span class="pattern-tag">graph</span>
                            <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Count connected components of '1's in a 2D grid.</p>
                            <p><strong>Pattern:</strong> DFS/BFS flood fill</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Operations:</strong> Insert, Delete, Replace - each costs 1.</li>
                                    <li><strong>DP State:</strong> dp[i][j] = min ops to convert word1[0..i] to word2[0..j].</li>
                                    <li><strong>If chars match:</strong> dp[i][j] = dp[i-1][j-1] (no operation needed).</li>
                                    <li><strong>If different:</strong> 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]).</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>DP State:</strong> dp[i] = LIS ending at index i.</li>
                                    <li><strong>Transition:</strong> For each j < i where nums[j] < nums[i]: dp[i] = max(dp[i], dp[j]+1)</li>
                                    <li><strong>O(n¬≤):</strong> Check all previous elements for each position.</li>
                                    <li><strong>O(n log n):</strong> Use binary search with patience sorting.</li>
                                </ol>
                            </div>

<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Scan Grid:</strong> When we find '1', it's a new island.</li>
                                    <li><strong>Mark Visited:</strong> Use DFS/BFS to mark all connected '1's.</li>
                                    <li><strong>Count:</strong> Each time we start a new DFS = one island.</li>
                                    <li><strong>Trick:</strong> Modify grid in-place (change '1' to '0') to mark visited.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">numIslands</span>(grid):
    <span class="keyword">if not</span> grid:
        <span class="keyword">return</span> <span class="number">0</span>

    rows, cols = <span class="keyword">len</span>(grid), <span class="keyword">len</span>(grid[<span class="number">0</span>])
    islands = <span class="number">0</span>

    <span class="keyword">def</span> <span class="function">dfs</span>(r, c):
        <span class="keyword">if</span> (r < <span class="number">0</span> <span class="keyword">or</span> r >= rows <span class="keyword">or</span>
            c < <span class="number">0</span> <span class="keyword">or</span> c >= cols <span class="keyword">or</span>
            grid[r][c] != <span class="string">'1'</span>):
            <span class="keyword">return</span>

        grid[r][c] = <span class="string">'0'</span>  <span class="comment"># Mark visited</span>
        dfs(r + <span class="number">1</span>, c)
        dfs(r - <span class="number">1</span>, c)
        dfs(r, c + <span class="number">1</span>)
        dfs(r, c - <span class="number">1</span>)

    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="keyword">range</span>(rows):
        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="keyword">range</span>(cols):
            <span class="keyword">if</span> grid[r][c] == <span class="string">'1'</span>:
                islands += <span class="number">1</span>
                dfs(r, c)

    <span class="keyword">return</span> islands

<span class="comment"># Time: O(m*n), Space: O(m*n) stack</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=pV2kpPD66nE" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="graph" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">207. Course Schedule</span><span class="pattern-tag">graph</span>
                            <a href="https://leetcode.com/problems/course-schedule/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Pattern:</strong> Detect cycle in directed graph using DFS</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Model as Graph:</strong> Courses = nodes, prerequisites = edges.</li>
                                    <li><strong>Cycle Detection:</strong> If cycle exists, can't complete all courses.</li>
                                    <li><strong>DFS Approach:</strong> Track visiting (in current path) vs visited (completed).</li>
                                    <li><strong>BFS/Kahn's:</strong> Topological sort - process nodes with no incoming edges.</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">canFinish</span>(numCourses, prerequisites):
    graph = {i: [] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(numCourses)}
    <span class="keyword">for</span> course, prereq <span class="keyword">in</span> prerequisites:
        graph[course].append(prereq)

    <span class="comment"># 0: unvisited, 1: visiting, 2: visited</span>
    state = [<span class="number">0</span>] * numCourses

    <span class="keyword">def</span> <span class="function">hasCycle</span>(course):
        <span class="keyword">if</span> state[course] == <span class="number">1</span>:
            <span class="keyword">return True</span>
        <span class="keyword">if</span> state[course] == <span class="number">2</span>:
            <span class="keyword">return False</span>

        state[course] = <span class="number">1</span>
        <span class="keyword">for</span> prereq <span class="keyword">in</span> graph[course]:
            <span class="keyword">if</span> hasCycle(prereq):
                <span class="keyword">return True</span>
        state[course] = <span class="number">2</span>
        <span class="keyword">return False</span>

    <span class="keyword">for</span> course <span class="keyword">in</span> <span class="keyword">range</span>(numCourses):
        <span class="keyword">if</span> hasCycle(course):
            <span class="keyword">return False</span>
    <span class="keyword">return True</span>

<span class="comment"># Time: O(V+E), Space: O(V+E)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=EgI5nU9etnU" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        
        <!-- Tries -->
        <section class="section" id="trie">
            <div class="section-header">
                <h2>üå≥ Tries (Prefix Trees)</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <h3>What is a Trie?</h3>
                <p>A tree-like data structure for efficient string operations. Each node represents a character, and paths from root to nodes represent prefixes. Excellent for autocomplete, spell checkers, and prefix matching.</p>

                <div class="applications">
                    <h5>üåç When to Use Tries</h5>
                    <ul>
                        <li><strong>Autocomplete:</strong> Find all words with given prefix</li>
                        <li><strong>Spell Checker:</strong> Check if word exists in dictionary</li>
                        <li><strong>Word Search:</strong> Search words in a grid</li>
                        <li><strong>IP Routing:</strong> Longest prefix matching</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=oobqoCJlHA0" target="_blank" class="link-btn">üì∫ NeetCode - Implement Trie</a>
                    <a href="https://www.youtube.com/watch?v=giiaIofn31A" target="_blank" class="link-btn">üì∫ Abdul Bari - Trie</a>
                </div>

                <h3>üíª Implementation</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'trie-py')">Python</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="trie-py"><span class="keyword">class</span> <span class="class-name">TrieNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.children = {}  <span class="comment"># char -> TrieNode</span>
        self.is_end = <span class="keyword">False</span>

<span class="keyword">class</span> <span class="class-name">Trie</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.root = TrieNode()
    
    <span class="keyword">def</span> <span class="function">insert</span>(self, word):
        node = self.root
        <span class="keyword">for</span> char <span class="keyword">in</span> word:
            <span class="keyword">if</span> char <span class="keyword">not in</span> node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = <span class="keyword">True</span>
    
    <span class="keyword">def</span> <span class="function">search</span>(self, word):
        node = self._find_node(word)
        <span class="keyword">return</span> node <span class="keyword">is not</span> <span class="keyword">None</span> <span class="keyword">and</span> node.is_end
    
    <span class="keyword">def</span> <span class="function">startsWith</span>(self, prefix):
        <span class="keyword">return</span> self._find_node(prefix) <span class="keyword">is not</span> <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">_find_node</span>(self, prefix):
        node = self.root
        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:
            <span class="keyword">if</span> char <span class="keyword">not in</span> node.children:
                <span class="keyword">return</span> <span class="keyword">None</span>
            node = node.children[char]
        <span class="keyword">return</span> node

<span class="comment"># Insert/Search: O(m) where m is word length</span></code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="trie" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">208. Implement Trie (Prefix Tree)</span>
                            <span class="pattern-tag">trie</span>
                            <a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Implement a trie with insert, search, and startsWith methods.</p>
                            <p><strong>Pattern:</strong> Basic Trie Implementation</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>TrieNode:</strong> Has children dict and is_end flag.</li>
                                    <li><strong>Insert:</strong> Create nodes for each char, mark last as end.</li>
                                    <li><strong>Search:</strong> Traverse chars, check if final node is end.</li>
                                    <li><strong>StartsWith:</strong> Same as search but don't check is_end.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="trie" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">211. Design Add and Search Words Data Structure</span>
                            <span class="pattern-tag">trie</span>
                            <a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Design data structure supporting '.' wildcard in search.</p>
                            <p><strong>Pattern:</strong> Trie + DFS for wildcards</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Add Word:</strong> Standard trie insert.</li>
                                    <li><strong>Search with '.':</strong> When '.', try all children (DFS).</li>
                                    <li><strong>Normal char:</strong> Follow the specific child.</li>
                                    <li><strong>Base Case:</strong> Reached end of word, check is_end.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="trie" data-difficulty="hard">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">212. Word Search II</span>
                            <span class="pattern-tag">trie</span>
                            <a href="https://leetcode.com/problems/word-search-ii/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find all words from dictionary in a 2D board.</p>
                            <p><strong>Pattern:</strong> Trie + Backtracking DFS</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Build Trie:</strong> Insert all words into trie.</li>
                                    <li><strong>DFS from each cell:</strong> Explore all 4 directions.</li>
                                    <li><strong>Prune:</strong> Stop if prefix not in trie.</li>
                                    <li><strong>Found Word:</strong> When is_end is True, add to result.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Union Find -->
        <section class="section" id="union-find">
            <div class="section-header">
                <h2>üîó Union-Find (Disjoint Set)</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <h3>What is Union-Find?</h3>
                <p>A data structure that tracks elements partitioned into disjoint sets. Supports two operations: Find (which set an element belongs to) and Union (merge two sets). Used for connectivity problems.</p>

                <div class="applications">
                    <h5>üåç When to Use Union-Find</h5>
                    <ul>
                        <li><strong>Connectivity:</strong> Are two nodes connected?</li>
                        <li><strong>Counting Components:</strong> How many separate groups?</li>
                        <li><strong>Cycle Detection:</strong> Does adding edge create cycle?</li>
                        <li><strong>Kruskal's MST:</strong> Minimum spanning tree</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=ibjEGG7ylHk" target="_blank" class="link-btn">üì∫ NeetCode - Union Find</a>
                    <a href="https://www.youtube.com/watch?v=ayW5B2W9hfo" target="_blank" class="link-btn">üì∫ Abdul Bari - Disjoint Sets</a>
                </div>

                <h3>ÔøΩÔøΩ Implementation</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'uf-py')">Python</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="uf-py"><span class="keyword">class</span> <span class="class-name">UnionFind</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, n):
        self.parent = list(range(n))  <span class="comment"># parent[i] = i initially</span>
        self.rank = [<span class="number">0</span>] * n        <span class="comment"># for union by rank</span>
        self.count = n                <span class="comment"># number of components</span>
    
    <span class="keyword">def</span> <span class="function">find</span>(self, x):
        <span class="comment"># Path compression</span>
        <span class="keyword">if</span> self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        <span class="keyword">return</span> self.parent[x]
    
    <span class="keyword">def</span> <span class="function">union</span>(self, x, y):
        px, py = self.find(x), self.find(y)
        <span class="keyword">if</span> px == py:
            <span class="keyword">return</span> <span class="keyword">False</span>  <span class="comment"># Already connected</span>
        
        <span class="comment"># Union by rank</span>
        <span class="keyword">if</span> self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        <span class="keyword">if</span> self.rank[px] == self.rank[py]:
            self.rank[px] += <span class="number">1</span>
        
        self.count -= <span class="number">1</span>
        <span class="keyword">return</span> <span class="keyword">True</span>
    
    <span class="keyword">def</span> <span class="function">connected</span>(self, x, y):
        <span class="keyword">return</span> self.find(x) == self.find(y)

<span class="comment"># Operations: O(Œ±(n)) ‚âà O(1) amortized</span></code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="union-find" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">200. Number of Islands (Union-Find)</span>
                            <span class="pattern-tag">union-find</span>
                            <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Count number of islands in a 2D grid.</p>
                            <p><strong>Pattern:</strong> Union-Find alternative to DFS</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Initialize:</strong> Each '1' cell is its own component.</li>
                                    <li><strong>Union Adjacent:</strong> Connect neighboring '1' cells.</li>
                                    <li><strong>Count:</strong> Number of unique roots = number of islands.</li>
                                    <li><strong>2D to 1D:</strong> Index = row * cols + col.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="union-find" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">547. Number of Provinces</span>
                            <span class="pattern-tag">union-find</span>
                            <a href="https://leetcode.com/problems/number-of-provinces/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find number of connected components in adjacency matrix.</p>
                            <p><strong>Pattern:</strong> Classic Union-Find</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Initialize:</strong> n cities, n components.</li>
                                    <li><strong>Process Connections:</strong> Union connected cities.</li>
                                    <li><strong>Result:</strong> Count remaining components.</li>
                                    <li><strong>Alternative:</strong> DFS/BFS also works.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="union-find" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">684. Redundant Connection</span>
                            <span class="pattern-tag">union-find</span>
                            <a href="https://leetcode.com/problems/redundant-connection/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find edge that creates a cycle in undirected graph.</p>
                            <p><strong>Pattern:</strong> Union-Find Cycle Detection</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Process edges:</strong> Try to union each edge.</li>
                                    <li><strong>Cycle Found:</strong> If nodes already connected, this edge is redundant.</li>
                                    <li><strong>Return Last:</strong> Return the last such edge.</li>
                                    <li><strong>Why Union-Find:</strong> Efficiently tracks connectivity.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Greedy Algorithms -->
        <section class="section" id="greedy">
            <div class="section-header">
                <h2>üí∞ Greedy Algorithms</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <h3>What is Greedy?</h3>
                <p>A strategy that makes the locally optimal choice at each step, hoping to find the global optimum. Works when local optimal choices lead to global optimal solution. Key: prove the greedy choice property.</p>

                <div class="applications">
                    <h5>üåç When Greedy Works</h5>
                    <ul>
                        <li><strong>Optimal Substructure:</strong> Optimal solution contains optimal solutions to subproblems</li>
                        <li><strong>Greedy Choice:</strong> Local optimal choice leads to global optimal</li>
                        <li><strong>Common Problems:</strong> Intervals, scheduling, Huffman coding</li>
                        <li><strong>Warning:</strong> Greedy doesn't always work - verify!</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=bC7o8P_Ste4" target="_blank" class="link-btn">üì∫ NeetCode - Greedy Algorithms</a>
                    <a href="https://www.youtube.com/watch?v=ARvQcqJ_-NY" target="_blank" class="link-btn">üì∫ Abdul Bari - Greedy</a>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="greedy" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">55. Jump Game</span>
                            <span class="pattern-tag">greedy</span>
                            <a href="https://leetcode.com/problems/jump-game/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Determine if you can reach the last index.</p>
                            <p><strong>Pattern:</strong> Track maximum reachable index</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Track maxReach:</strong> Farthest index we can reach.</li>
                                    <li><strong>At each i:</strong> maxReach = max(maxReach, i + nums[i])</li>
                                    <li><strong>If i > maxReach:</strong> Can't reach this index, return False.</li>
                                    <li><strong>If maxReach >= n-1:</strong> Can reach end, return True.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="greedy" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">45. Jump Game II</span>
                            <span class="pattern-tag">greedy</span>
                            <a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find minimum jumps to reach the last index.</p>
                            <p><strong>Pattern:</strong> BFS-like level by level expansion</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Track:</strong> Current level end and next level farthest.</li>
                                    <li><strong>At each i:</strong> Update farthest reachable.</li>
                                    <li><strong>When i == currentEnd:</strong> Must jump, update currentEnd.</li>
                                    <li><strong>Count jumps:</strong> Increment when we reach current level end.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="greedy" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">134. Gas Station</span>
                            <span class="pattern-tag">greedy</span>
                            <a href="https://leetcode.com/problems/gas-station/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find starting gas station to complete the circuit.</p>
                            <p><strong>Pattern:</strong> Track deficit and reset start</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Check Feasibility:</strong> Total gas >= total cost.</li>
                                    <li><strong>Track Tank:</strong> Current tank = gas[i] - cost[i].</li>
                                    <li><strong>If tank < 0:</strong> Can't start from any previous station.</li>
                                    <li><strong>Reset:</strong> Start from i+1, reset tank.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="greedy" data-difficulty="hard">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-hard">Hard</span>
                            <span class="problem-title">135. Candy</span>
                            <span class="pattern-tag">greedy</span>
                            <a href="https://leetcode.com/problems/candy/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Distribute minimum candies based on ratings.</p>
                            <p><strong>Pattern:</strong> Two-pass greedy</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Initialize:</strong> Everyone gets 1 candy.</li>
                                    <li><strong>Left Pass:</strong> If rating[i] > rating[i-1], candy[i] = candy[i-1] + 1.</li>
                                    <li><strong>Right Pass:</strong> If rating[i] > rating[i+1], candy[i] = max(candy[i], candy[i+1] + 1).</li>
                                    <li><strong>Sum:</strong> Total candies needed.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


        <!-- Bit Manipulation -->
        <section class="section" id="bit-manipulation">
            <div class="section-header">
                <h2>üî¢ Bit Manipulation</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <h3>What is Bit Manipulation?</h3>
                <p>Operating directly on binary representations of numbers. Extremely efficient for certain problems. Key operations: AND (&), OR (|), XOR (^), NOT (~), Left Shift (<<), Right Shift (>>).</p>

                <div class="applications">
                    <h5>üîß Essential Bit Tricks</h5>
                    <ul>
                        <li><strong>n & (n-1):</strong> Remove rightmost 1 bit (count set bits)</li>
                        <li><strong>n & (-n):</strong> Isolate rightmost 1 bit</li>
                        <li><strong>n ^ n = 0:</strong> XOR same numbers cancel out</li>
                        <li><strong>n & 1:</strong> Check if odd (last bit is 1)</li>
                        <li><strong>n << 1:</strong> Multiply by 2</li>
                        <li><strong>n >> 1:</strong> Divide by 2</li>
                    </ul>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=5Km3utixwZs" target="_blank" class="link-btn">üì∫ NeetCode - Bit Manipulation</a>
                </div>

                <h3>üíª Common Patterns</h3>
                <div class="code-tabs">
                    <button class="code-tab active" onclick="switchTab(this, 'bit-py')">Python</button>
                </div>
                <div class="code-block">
                    <code class="code-content active" id="bit-py"><span class="comment"># Count set bits (1s)</span>
<span class="keyword">def</span> <span class="function">count_bits</span>(n):
    count = <span class="number">0</span>
    <span class="keyword">while</span> n:
        n &= (n - <span class="number">1</span>)  <span class="comment"># Remove rightmost 1</span>
        count += <span class="number">1</span>
    <span class="keyword">return</span> count

<span class="comment"># Check if power of 2</span>
<span class="keyword">def</span> <span class="function">is_power_of_two</span>(n):
    <span class="keyword">return</span> n > <span class="number">0</span> <span class="keyword">and</span> (n & (n - <span class="number">1</span>)) == <span class="number">0</span>

<span class="comment"># Find single number (others appear twice)</span>
<span class="keyword">def</span> <span class="function">single_number</span>(nums):
    result = <span class="number">0</span>
    <span class="keyword">for</span> num <span class="keyword">in</span> nums:
        result ^= num  <span class="comment"># XOR cancels pairs</span>
    <span class="keyword">return</span> result

<span class="comment"># Get/Set/Clear bit at position i</span>
get_bit = <span class="keyword">lambda</span> n, i: (n >> i) & <span class="number">1</span>
set_bit = <span class="keyword">lambda</span> n, i: n | (<span class="number">1</span> << i)
clear_bit = <span class="keyword">lambda</span> n, i: n & ~(<span class="number">1</span> << i)</code>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="bit" data-difficulty="easy">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">136. Single Number</span>
                            <span class="pattern-tag">bit</span>
                            <a href="https://leetcode.com/problems/single-number/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Find the single number where every other appears twice.</p>
                            <p><strong>Pattern:</strong> XOR all numbers</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>XOR Property:</strong> a ^ a = 0, a ^ 0 = a</li>
                                    <li><strong>XOR all:</strong> Pairs cancel out, single remains.</li>
                                    <li><strong>Time:</strong> O(n), Space: O(1)</li>
                                    <li><strong>No extra space needed!</strong></li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="bit" data-difficulty="easy">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-easy">Easy</span>
                            <span class="problem-title">191. Number of 1 Bits</span>
                            <span class="pattern-tag">bit</span>
                            <a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Count the number of 1 bits (Hamming weight).</p>
                            <p><strong>Pattern:</strong> n & (n-1) trick</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>n & (n-1):</strong> Removes rightmost 1 bit.</li>
                                    <li><strong>Count:</strong> How many times until n becomes 0.</li>
                                    <li><strong>Alternative:</strong> Check each bit with n & 1, then n >>= 1.</li>
                                    <li><strong>Time:</strong> O(number of 1 bits)</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="bit" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">371. Sum of Two Integers</span>
                            <span class="pattern-tag">bit</span>
                            <a href="https://leetcode.com/problems/sum-of-two-integers/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Add two integers without + or - operators.</p>
                            <p><strong>Pattern:</strong> XOR for sum, AND for carry</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>XOR (a ^ b):</strong> Sum without carry.</li>
                                    <li><strong>AND (a & b) << 1:</strong> Carry bits.</li>
                                    <li><strong>Repeat:</strong> Until no carry left.</li>
                                    <li><strong>Handle negatives:</strong> Use mask for Python.</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                    <div class="problem-item" data-pattern="bit" data-difficulty="medium">
                        <div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">338. Counting Bits</span>
                            <span class="pattern-tag">bit</span>
                            <a href="https://leetcode.com/problems/counting-bits/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Count bits for all numbers from 0 to n.</p>
                            <p><strong>Pattern:</strong> DP with bit manipulation</p>
                            <div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Pattern:</strong> dp[i] = dp[i >> 1] + (i & 1)</li>
                                    <li><strong>Why:</strong> i >> 1 removes last bit, (i & 1) adds it back if it was 1.</li>
                                    <li><strong>Alternative:</strong> dp[i] = dp[i & (i-1)] + 1</li>
                                    <li><strong>Time:</strong> O(n), Space: O(n)</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

<!-- Expert Level Header -->
        <section class="section" id="expert">
            <div class="section-header">
                <h2>üèÜ Expert Level</h2>
                <span class="badge badge-expert">Expert</span>
            </div>
            <div class="section-body">
                <p>Master these advanced concepts to tackle the most challenging interview problems and competitive programming contests.</p>
            </div>
        </section>

        <!-- Backtracking Section -->
        <section class="section" id="backtracking">
            <div class="section-header">
                <h2>üîÑ Backtracking</h2>
                <span class="badge badge-advanced">Advanced</span>
            </div>
            <div class="section-body">
                <div class="progress-check">
                    <input type="checkbox" id="check-backtracking" onchange="updateProgress()">
                    <label for="check-backtracking">Mark as completed</label>
                </div>

                <h3>What is Backtracking?</h3>
                <p>Backtracking is an algorithmic technique that builds solutions incrementally, abandoning a solution ("backtracking") as soon as it determines the solution cannot be completed. It's used for constraint satisfaction problems.</p>

                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>Common Patterns</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>Subsets / Power Set</li>
                            <li>Permutations</li>
                            <li>Combinations</li>
                            <li>N-Queens, Sudoku</li>
                        </ul>
                    </div>
                    <div class="topic-card">
                        <h4>Template</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>Make a choice</li>
                            <li>Explore (recurse)</li>
                            <li>Undo the choice</li>
                        </ul>
                    </div>
                </div>

                <h3>üìπ Video Tutorials</h3>
                <div class="link-list">
                    <a href="https://www.youtube.com/watch?v=DKCbsiDBN6c" target="_blank" class="link-btn">üì∫ Backtracking - Abdul Bari</a>
                </div>

                <h3>üéØ LeetCode Problems</h3>
                <div class="problem-list">
                    <div class="problem-item" data-pattern="backtracking" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">78. Subsets</span><span class="pattern-tag">backtracking</span>
                            <a href="https://leetcode.com/problems/subsets/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <p><strong>Problem:</strong> Generate all possible subsets of a set.</p>
<div class="thought-process">
                                <h4>üß† Thought Process</h4>
                                <ol>
                                    <li><strong>Choice at Each Element:</strong> Include it or exclude it.</li>
                                    <li><strong>Backtracking:</strong> Add element, recurse, remove element.</li>
                                    <li><strong>Iterative:</strong> Start with [[]], for each num, add it to all existing subsets.</li>
                                    <li><strong>Total Subsets:</strong> 2^n (each element has 2 choices).</li>
                                </ol>
                            </div>

                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">subsets</span>(nums):
    result = []

    <span class="keyword">def</span> <span class="function">backtrack</span>(start, path):
        result.append(path[:])

        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(start, <span class="keyword">len</span>(nums)):
            path.append(nums[i])
            backtrack(i + <span class="number">1</span>, path)
            path.pop()  <span class="comment"># Backtrack</span>

    backtrack(<span class="number">0</span>, [])
    <span class="keyword">return</span> result

<span class="comment"># Time: O(n * 2^n), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=REOH22Xwdkk" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>

                    <div class="problem-item" data-pattern="backtracking" data-difficulty="medium"><div class="problem-header" onclick="toggleProblem(this)">
                            <span class="badge badge-medium">Medium</span>
                            <span class="problem-title">46. Permutations</span><span class="pattern-tag">backtracking</span>
                            <a href="https://leetcode.com/problems/permutations/" target="_blank" class="link-btn" onclick="event.stopPropagation()">LeetCode</a>
                        </div>
                        <div class="problem-content">
                            <div class="code-block">
                                <code class="code-content active"><span class="keyword">def</span> <span class="function">permute</span>(nums):
    result = []

    <span class="keyword">def</span> <span class="function">backtrack</span>(path, remaining):
        <span class="keyword">if not</span> remaining:
            result.append(path[:])
            <span class="keyword">return</span>

        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="keyword">len</span>(remaining)):
            path.append(remaining[i])
            backtrack(path, remaining[:i] + remaining[i+<span class="number">1</span>:])
            path.pop()

    backtrack([], nums)
    <span class="keyword">return</span> result

<span class="comment"># Time: O(n * n!), Space: O(n)</span></code>
                            </div>
                            <div class="link-list">
                                <a href="https://www.youtube.com/watch?v=s7AvT7cGdSo" target="_blank" class="link-btn">üì∫ NeetCode Solution</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Interview Tips Section -->
        <section class="section" id="resources">
            <div class="section-header">
                <h2>üíº Interview Tips</h2>
                <span class="badge badge-beginner">Essential</span>
            </div>
            <div class="section-body">
                <h3>üéØ Problem-Solving Framework</h3>
                <div class="topic-grid">
                    <div class="topic-card">
                        <h4>1. Understand</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>Clarify inputs/outputs</li>
                            <li>Ask about edge cases</li>
                            <li>Confirm constraints</li>
                            <li>Work through examples</li>
                        </ul>
                    </div>
                    <div class="topic-card">
                        <h4>2. Plan</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>Identify patterns</li>
                            <li>Consider brute force first</li>
                            <li>Optimize step by step</li>
                            <li>Discuss trade-offs</li>
                        </ul>
                    </div>
                    <div class="topic-card">
                        <h4>3. Implement</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>Write clean code</li>
                            <li>Use meaningful names</li>
                            <li>Think out loud</li>
                            <li>Handle edge cases</li>
                        </ul>
                    </div>
                    <div class="topic-card">
                        <h4>4. Verify</h4>
                        <ul style="font-size: 0.9rem; margin-left: 1rem;">
                            <li>Trace through examples</li>
                            <li>Test edge cases</li>
                            <li>Analyze complexity</li>
                            <li>Discuss improvements</li>
                        </ul>
                    </div>
                </div>

                <h3>üìö Recommended Study Plan</h3>
                <div class="applications">
                    <ul>
                        <li><strong>Week 1-2:</strong> Arrays, Strings, Big O</li>
                        <li><strong>Week 3-4:</strong> Sorting, Searching, Two Pointers</li>
                        <li><strong>Week 5-6:</strong> Linked Lists, Stacks, Queues</li>
                        <li><strong>Week 7-8:</strong> Hash Tables, Trees, BST</li>
                        <li><strong>Week 9-10:</strong> Heaps, Graphs</li>
                        <li><strong>Week 11-12:</strong> Dynamic Programming, Backtracking</li>
                    </ul>
                </div>

                <h3>üîó Additional Resources</h3>
                <div class="link-list">
                    <a href="https://neetcode.io/roadmap" target="_blank" class="link-btn">üìö NeetCode Roadmap</a>
                    <a href="https://www.techinterviewhandbook.org/" target="_blank" class="link-btn">üìñ Tech Interview Handbook</a>
                    <a href="https://leetcode.com/studyplan/top-interview-150/" target="_blank" class="link-btn">üéØ LeetCode Top 150</a>
                    <a href="https://www.youtube.com/c/NeetCode" target="_blank" class="link-btn">üì∫ NeetCode YouTube</a>
                </div>
            </div>
        </section>

    </main>

    <footer>
        <p>Built with ‚ù§Ô∏è for aspiring software engineers</p>
        <p>Keep practicing, stay consistent, and you'll ace those interviews!</p>
    </footer>

    <script>
        
        // Filter state
        let currentDifficulty = 'all';
        let currentPattern = 'all';
        let searchQuery = '';

        // Switch code tabs (Python/Java/C++)
        function switchTab(button, tabId) {
            // Get the code block container
            const codeBlock = button.closest('.section-body') || button.parentElement.parentElement;
            
            // Remove active from all tabs in this section
            const tabs = button.parentElement.querySelectorAll('.code-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Add active to clicked tab
            button.classList.add('active');
            
            // Hide all code content in this section
            const codeContents = codeBlock.querySelectorAll('.code-content');
            codeContents.forEach(code => code.classList.remove('active'));
            
            // Show the selected code content
            const selectedCode = document.getElementById(tabId);
            if (selectedCode) {
                selectedCode.classList.add('active');
            }
        }

        // Toggle navigation menu (mobile)
        function toggleNav() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('open');
        }

        // Toggle table of contents
        function toggleToc() {
            const toc = document.getElementById('toc');
            toc.classList.toggle('visible');
            toc.classList.toggle('hidden');
        }

        // Initialize filters on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateFilterCounts();
        });

        // Search and filter problems
        function filterProblems() {
            searchQuery = document.getElementById('searchInput').value.toLowerCase();
            applyFilters();
        }

        // Set difficulty filter
        function setDifficultyFilter(difficulty) {
            currentDifficulty = difficulty;
            // Update button states
            document.querySelectorAll('#difficultyFilters .filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.difficulty === difficulty) btn.classList.add('active');
            });
            applyFilters();
        }

        // Set pattern filter
        function setPatternFilter(pattern) {
            currentPattern = pattern;
            // Update button states
            document.querySelectorAll('#patternFilters .filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.pattern === pattern) btn.classList.add('active');
            });
            applyFilters();
        }

        // Apply all filters
        function applyFilters() {
            const problems = document.querySelectorAll('.problem-item');
            let visibleCount = 0;

            problems.forEach(problem => {
                const title = problem.querySelector('.problem-title')?.textContent.toLowerCase() || '';
                const difficulty = problem.dataset.difficulty || '';
                const pattern = problem.dataset.pattern || '';
                const content = problem.querySelector('.problem-content')?.textContent.toLowerCase() || '';

                // Check all conditions
                const matchesSearch = searchQuery === '' || title.includes(searchQuery) || content.includes(searchQuery);
                const matchesDifficulty = currentDifficulty === 'all' || difficulty === currentDifficulty;
                const matchesPattern = currentPattern === 'all' || pattern === currentPattern;

                if (matchesSearch && matchesDifficulty && matchesPattern) {
                    problem.classList.remove('problem-hidden');
                    visibleCount++;
                } else {
                    problem.classList.add('problem-hidden');
                }
            });

            // Update count
            document.getElementById('visibleCount').textContent = visibleCount;
        }

        // Update filter counts on load
        function updateFilterCounts() {
            const problems = document.querySelectorAll('.problem-item');
            document.getElementById('totalProblems').textContent = problems.length;
            document.getElementById('visibleCount').textContent = problems.length;
        }

// Toggle problem solution visibility
        function toggleProblem(header) {
            const problemItem = header.parentElement;
            problemItem.classList.toggle('open');
        }

        // Update progress tracking
        function updateProgress() {
            const checkboxes = document.querySelectorAll('.progress-check input[type="checkbox"]');
            const total = checkboxes.length;
            let completed = 0;

            checkboxes.forEach(cb => {
                if (cb.checked) completed++;
                // Save to localStorage
                localStorage.setItem(cb.id, cb.checked);
            });

            const percentage = Math.round((completed / total) * 100);
            document.getElementById('progress-fill').style.width = percentage + '%';
            document.getElementById('progress-text').textContent = percentage + '% Complete';
        }

        // Load saved progress on page load
        document.addEventListener('DOMContentLoaded', function() {
            const checkboxes = document.querySelectorAll('.progress-check input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const saved = localStorage.getItem(cb.id);
                if (saved === 'true') {
                    cb.checked = true;
                }
            });
            updateProgress();
        });

        // Smooth scrolling for navigation
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>
